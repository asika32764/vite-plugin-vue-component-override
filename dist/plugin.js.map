{"version":3,"file":"plugin.js","sources":["../node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs","../node_modules/magic-string/dist/magic-string.es.mjs","../node_modules/@isaacs/balanced-match/dist/esm/index.js","../node_modules/@isaacs/brace-expansion/dist/esm/index.js","../node_modules/minimatch/dist/esm/assert-valid-pattern.js","../node_modules/minimatch/dist/esm/brace-expressions.js","../node_modules/minimatch/dist/esm/unescape.js","../node_modules/minimatch/dist/esm/ast.js","../node_modules/minimatch/dist/esm/escape.js","../node_modules/minimatch/dist/esm/index.js","../src/plugin.ts"],"sourcesContent":["// src/vlq.ts\nvar comma = \",\".charCodeAt(0);\nvar semicolon = \";\".charCodeAt(0);\nvar chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar intToChar = new Uint8Array(64);\nvar charToInt = new Uint8Array(128);\nfor (let i = 0; i < chars.length; i++) {\n  const c = chars.charCodeAt(i);\n  intToChar[i] = c;\n  charToInt[c] = i;\n}\nfunction decodeInteger(reader, relative) {\n  let value = 0;\n  let shift = 0;\n  let integer = 0;\n  do {\n    const c = reader.next();\n    integer = charToInt[c];\n    value |= (integer & 31) << shift;\n    shift += 5;\n  } while (integer & 32);\n  const shouldNegate = value & 1;\n  value >>>= 1;\n  if (shouldNegate) {\n    value = -2147483648 | -value;\n  }\n  return relative + value;\n}\nfunction encodeInteger(builder, num, relative) {\n  let delta = num - relative;\n  delta = delta < 0 ? -delta << 1 | 1 : delta << 1;\n  do {\n    let clamped = delta & 31;\n    delta >>>= 5;\n    if (delta > 0) clamped |= 32;\n    builder.write(intToChar[clamped]);\n  } while (delta > 0);\n  return num;\n}\nfunction hasMoreVlq(reader, max) {\n  if (reader.pos >= max) return false;\n  return reader.peek() !== comma;\n}\n\n// src/strings.ts\nvar bufLength = 1024 * 16;\nvar td = typeof TextDecoder !== \"undefined\" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== \"undefined\" ? {\n  decode(buf) {\n    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n    return out.toString();\n  }\n} : {\n  decode(buf) {\n    let out = \"\";\n    for (let i = 0; i < buf.length; i++) {\n      out += String.fromCharCode(buf[i]);\n    }\n    return out;\n  }\n};\nvar StringWriter = class {\n  constructor() {\n    this.pos = 0;\n    this.out = \"\";\n    this.buffer = new Uint8Array(bufLength);\n  }\n  write(v) {\n    const { buffer } = this;\n    buffer[this.pos++] = v;\n    if (this.pos === bufLength) {\n      this.out += td.decode(buffer);\n      this.pos = 0;\n    }\n  }\n  flush() {\n    const { buffer, out, pos } = this;\n    return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;\n  }\n};\nvar StringReader = class {\n  constructor(buffer) {\n    this.pos = 0;\n    this.buffer = buffer;\n  }\n  next() {\n    return this.buffer.charCodeAt(this.pos++);\n  }\n  peek() {\n    return this.buffer.charCodeAt(this.pos);\n  }\n  indexOf(char) {\n    const { buffer, pos } = this;\n    const idx = buffer.indexOf(char, pos);\n    return idx === -1 ? buffer.length : idx;\n  }\n};\n\n// src/scopes.ts\nvar EMPTY = [];\nfunction decodeOriginalScopes(input) {\n  const { length } = input;\n  const reader = new StringReader(input);\n  const scopes = [];\n  const stack = [];\n  let line = 0;\n  for (; reader.pos < length; reader.pos++) {\n    line = decodeInteger(reader, line);\n    const column = decodeInteger(reader, 0);\n    if (!hasMoreVlq(reader, length)) {\n      const last = stack.pop();\n      last[2] = line;\n      last[3] = column;\n      continue;\n    }\n    const kind = decodeInteger(reader, 0);\n    const fields = decodeInteger(reader, 0);\n    const hasName = fields & 1;\n    const scope = hasName ? [line, column, 0, 0, kind, decodeInteger(reader, 0)] : [line, column, 0, 0, kind];\n    let vars = EMPTY;\n    if (hasMoreVlq(reader, length)) {\n      vars = [];\n      do {\n        const varsIndex = decodeInteger(reader, 0);\n        vars.push(varsIndex);\n      } while (hasMoreVlq(reader, length));\n    }\n    scope.vars = vars;\n    scopes.push(scope);\n    stack.push(scope);\n  }\n  return scopes;\n}\nfunction encodeOriginalScopes(scopes) {\n  const writer = new StringWriter();\n  for (let i = 0; i < scopes.length; ) {\n    i = _encodeOriginalScopes(scopes, i, writer, [0]);\n  }\n  return writer.flush();\n}\nfunction _encodeOriginalScopes(scopes, index, writer, state) {\n  const scope = scopes[index];\n  const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, 4: kind, vars } = scope;\n  if (index > 0) writer.write(comma);\n  state[0] = encodeInteger(writer, startLine, state[0]);\n  encodeInteger(writer, startColumn, 0);\n  encodeInteger(writer, kind, 0);\n  const fields = scope.length === 6 ? 1 : 0;\n  encodeInteger(writer, fields, 0);\n  if (scope.length === 6) encodeInteger(writer, scope[5], 0);\n  for (const v of vars) {\n    encodeInteger(writer, v, 0);\n  }\n  for (index++; index < scopes.length; ) {\n    const next = scopes[index];\n    const { 0: l, 1: c } = next;\n    if (l > endLine || l === endLine && c >= endColumn) {\n      break;\n    }\n    index = _encodeOriginalScopes(scopes, index, writer, state);\n  }\n  writer.write(comma);\n  state[0] = encodeInteger(writer, endLine, state[0]);\n  encodeInteger(writer, endColumn, 0);\n  return index;\n}\nfunction decodeGeneratedRanges(input) {\n  const { length } = input;\n  const reader = new StringReader(input);\n  const ranges = [];\n  const stack = [];\n  let genLine = 0;\n  let definitionSourcesIndex = 0;\n  let definitionScopeIndex = 0;\n  let callsiteSourcesIndex = 0;\n  let callsiteLine = 0;\n  let callsiteColumn = 0;\n  let bindingLine = 0;\n  let bindingColumn = 0;\n  do {\n    const semi = reader.indexOf(\";\");\n    let genColumn = 0;\n    for (; reader.pos < semi; reader.pos++) {\n      genColumn = decodeInteger(reader, genColumn);\n      if (!hasMoreVlq(reader, semi)) {\n        const last = stack.pop();\n        last[2] = genLine;\n        last[3] = genColumn;\n        continue;\n      }\n      const fields = decodeInteger(reader, 0);\n      const hasDefinition = fields & 1;\n      const hasCallsite = fields & 2;\n      const hasScope = fields & 4;\n      let callsite = null;\n      let bindings = EMPTY;\n      let range;\n      if (hasDefinition) {\n        const defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);\n        definitionScopeIndex = decodeInteger(\n          reader,\n          definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0\n        );\n        definitionSourcesIndex = defSourcesIndex;\n        range = [genLine, genColumn, 0, 0, defSourcesIndex, definitionScopeIndex];\n      } else {\n        range = [genLine, genColumn, 0, 0];\n      }\n      range.isScope = !!hasScope;\n      if (hasCallsite) {\n        const prevCsi = callsiteSourcesIndex;\n        const prevLine = callsiteLine;\n        callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);\n        const sameSource = prevCsi === callsiteSourcesIndex;\n        callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);\n        callsiteColumn = decodeInteger(\n          reader,\n          sameSource && prevLine === callsiteLine ? callsiteColumn : 0\n        );\n        callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];\n      }\n      range.callsite = callsite;\n      if (hasMoreVlq(reader, semi)) {\n        bindings = [];\n        do {\n          bindingLine = genLine;\n          bindingColumn = genColumn;\n          const expressionsCount = decodeInteger(reader, 0);\n          let expressionRanges;\n          if (expressionsCount < -1) {\n            expressionRanges = [[decodeInteger(reader, 0)]];\n            for (let i = -1; i > expressionsCount; i--) {\n              const prevBl = bindingLine;\n              bindingLine = decodeInteger(reader, bindingLine);\n              bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);\n              const expression = decodeInteger(reader, 0);\n              expressionRanges.push([expression, bindingLine, bindingColumn]);\n            }\n          } else {\n            expressionRanges = [[expressionsCount]];\n          }\n          bindings.push(expressionRanges);\n        } while (hasMoreVlq(reader, semi));\n      }\n      range.bindings = bindings;\n      ranges.push(range);\n      stack.push(range);\n    }\n    genLine++;\n    reader.pos = semi + 1;\n  } while (reader.pos < length);\n  return ranges;\n}\nfunction encodeGeneratedRanges(ranges) {\n  if (ranges.length === 0) return \"\";\n  const writer = new StringWriter();\n  for (let i = 0; i < ranges.length; ) {\n    i = _encodeGeneratedRanges(ranges, i, writer, [0, 0, 0, 0, 0, 0, 0]);\n  }\n  return writer.flush();\n}\nfunction _encodeGeneratedRanges(ranges, index, writer, state) {\n  const range = ranges[index];\n  const {\n    0: startLine,\n    1: startColumn,\n    2: endLine,\n    3: endColumn,\n    isScope,\n    callsite,\n    bindings\n  } = range;\n  if (state[0] < startLine) {\n    catchupLine(writer, state[0], startLine);\n    state[0] = startLine;\n    state[1] = 0;\n  } else if (index > 0) {\n    writer.write(comma);\n  }\n  state[1] = encodeInteger(writer, range[1], state[1]);\n  const fields = (range.length === 6 ? 1 : 0) | (callsite ? 2 : 0) | (isScope ? 4 : 0);\n  encodeInteger(writer, fields, 0);\n  if (range.length === 6) {\n    const { 4: sourcesIndex, 5: scopesIndex } = range;\n    if (sourcesIndex !== state[2]) {\n      state[3] = 0;\n    }\n    state[2] = encodeInteger(writer, sourcesIndex, state[2]);\n    state[3] = encodeInteger(writer, scopesIndex, state[3]);\n  }\n  if (callsite) {\n    const { 0: sourcesIndex, 1: callLine, 2: callColumn } = range.callsite;\n    if (sourcesIndex !== state[4]) {\n      state[5] = 0;\n      state[6] = 0;\n    } else if (callLine !== state[5]) {\n      state[6] = 0;\n    }\n    state[4] = encodeInteger(writer, sourcesIndex, state[4]);\n    state[5] = encodeInteger(writer, callLine, state[5]);\n    state[6] = encodeInteger(writer, callColumn, state[6]);\n  }\n  if (bindings) {\n    for (const binding of bindings) {\n      if (binding.length > 1) encodeInteger(writer, -binding.length, 0);\n      const expression = binding[0][0];\n      encodeInteger(writer, expression, 0);\n      let bindingStartLine = startLine;\n      let bindingStartColumn = startColumn;\n      for (let i = 1; i < binding.length; i++) {\n        const expRange = binding[i];\n        bindingStartLine = encodeInteger(writer, expRange[1], bindingStartLine);\n        bindingStartColumn = encodeInteger(writer, expRange[2], bindingStartColumn);\n        encodeInteger(writer, expRange[0], 0);\n      }\n    }\n  }\n  for (index++; index < ranges.length; ) {\n    const next = ranges[index];\n    const { 0: l, 1: c } = next;\n    if (l > endLine || l === endLine && c >= endColumn) {\n      break;\n    }\n    index = _encodeGeneratedRanges(ranges, index, writer, state);\n  }\n  if (state[0] < endLine) {\n    catchupLine(writer, state[0], endLine);\n    state[0] = endLine;\n    state[1] = 0;\n  } else {\n    writer.write(comma);\n  }\n  state[1] = encodeInteger(writer, endColumn, state[1]);\n  return index;\n}\nfunction catchupLine(writer, lastLine, line) {\n  do {\n    writer.write(semicolon);\n  } while (++lastLine < line);\n}\n\n// src/sourcemap-codec.ts\nfunction decode(mappings) {\n  const { length } = mappings;\n  const reader = new StringReader(mappings);\n  const decoded = [];\n  let genColumn = 0;\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n  do {\n    const semi = reader.indexOf(\";\");\n    const line = [];\n    let sorted = true;\n    let lastCol = 0;\n    genColumn = 0;\n    while (reader.pos < semi) {\n      let seg;\n      genColumn = decodeInteger(reader, genColumn);\n      if (genColumn < lastCol) sorted = false;\n      lastCol = genColumn;\n      if (hasMoreVlq(reader, semi)) {\n        sourcesIndex = decodeInteger(reader, sourcesIndex);\n        sourceLine = decodeInteger(reader, sourceLine);\n        sourceColumn = decodeInteger(reader, sourceColumn);\n        if (hasMoreVlq(reader, semi)) {\n          namesIndex = decodeInteger(reader, namesIndex);\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];\n        } else {\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];\n        }\n      } else {\n        seg = [genColumn];\n      }\n      line.push(seg);\n      reader.pos++;\n    }\n    if (!sorted) sort(line);\n    decoded.push(line);\n    reader.pos = semi + 1;\n  } while (reader.pos <= length);\n  return decoded;\n}\nfunction sort(line) {\n  line.sort(sortComparator);\n}\nfunction sortComparator(a, b) {\n  return a[0] - b[0];\n}\nfunction encode(decoded) {\n  const writer = new StringWriter();\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    if (i > 0) writer.write(semicolon);\n    if (line.length === 0) continue;\n    let genColumn = 0;\n    for (let j = 0; j < line.length; j++) {\n      const segment = line[j];\n      if (j > 0) writer.write(comma);\n      genColumn = encodeInteger(writer, segment[0], genColumn);\n      if (segment.length === 1) continue;\n      sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);\n      sourceLine = encodeInteger(writer, segment[2], sourceLine);\n      sourceColumn = encodeInteger(writer, segment[3], sourceColumn);\n      if (segment.length === 4) continue;\n      namesIndex = encodeInteger(writer, segment[4], namesIndex);\n    }\n  }\n  return writer.flush();\n}\nexport {\n  decode,\n  decodeGeneratedRanges,\n  decodeOriginalScopes,\n  encode,\n  encodeGeneratedRanges,\n  encodeOriginalScopes\n};\n//# sourceMappingURL=sourcemap-codec.mjs.map\n","import { encode } from '@jridgewell/sourcemap-codec';\n\nclass BitSet {\n\tconstructor(arg) {\n\t\tthis.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n\t}\n\n\tadd(n) {\n\t\tthis.bits[n >> 5] |= 1 << (n & 31);\n\t}\n\n\thas(n) {\n\t\treturn !!(this.bits[n >> 5] & (1 << (n & 31)));\n\t}\n}\n\nclass Chunk {\n\tconstructor(start, end, content) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.original = content;\n\n\t\tthis.intro = '';\n\t\tthis.outro = '';\n\n\t\tthis.content = content;\n\t\tthis.storeName = false;\n\t\tthis.edited = false;\n\n\t\t{\n\t\t\tthis.previous = null;\n\t\t\tthis.next = null;\n\t\t}\n\t}\n\n\tappendLeft(content) {\n\t\tthis.outro += content;\n\t}\n\n\tappendRight(content) {\n\t\tthis.intro = this.intro + content;\n\t}\n\n\tclone() {\n\t\tconst chunk = new Chunk(this.start, this.end, this.original);\n\n\t\tchunk.intro = this.intro;\n\t\tchunk.outro = this.outro;\n\t\tchunk.content = this.content;\n\t\tchunk.storeName = this.storeName;\n\t\tchunk.edited = this.edited;\n\n\t\treturn chunk;\n\t}\n\n\tcontains(index) {\n\t\treturn this.start < index && index < this.end;\n\t}\n\n\teachNext(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.next;\n\t\t}\n\t}\n\n\teachPrevious(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.previous;\n\t\t}\n\t}\n\n\tedit(content, storeName, contentOnly) {\n\t\tthis.content = content;\n\t\tif (!contentOnly) {\n\t\t\tthis.intro = '';\n\t\t\tthis.outro = '';\n\t\t}\n\t\tthis.storeName = storeName;\n\n\t\tthis.edited = true;\n\n\t\treturn this;\n\t}\n\n\tprependLeft(content) {\n\t\tthis.outro = content + this.outro;\n\t}\n\n\tprependRight(content) {\n\t\tthis.intro = content + this.intro;\n\t}\n\n\treset() {\n\t\tthis.intro = '';\n\t\tthis.outro = '';\n\t\tif (this.edited) {\n\t\t\tthis.content = this.original;\n\t\t\tthis.storeName = false;\n\t\t\tthis.edited = false;\n\t\t}\n\t}\n\n\tsplit(index) {\n\t\tconst sliceIndex = index - this.start;\n\n\t\tconst originalBefore = this.original.slice(0, sliceIndex);\n\t\tconst originalAfter = this.original.slice(sliceIndex);\n\n\t\tthis.original = originalBefore;\n\n\t\tconst newChunk = new Chunk(index, this.end, originalAfter);\n\t\tnewChunk.outro = this.outro;\n\t\tthis.outro = '';\n\n\t\tthis.end = index;\n\n\t\tif (this.edited) {\n\t\t\t// after split we should save the edit content record into the correct chunk\n\t\t\t// to make sure sourcemap correct\n\t\t\t// For example:\n\t\t\t// '  test'.trim()\n\t\t\t//     split   -> '  ' + 'test'\n\t\t\t//   ✔️ edit    -> '' + 'test'\n\t\t\t//   ✖️ edit    -> 'test' + ''\n\t\t\t// TODO is this block necessary?...\n\t\t\tnewChunk.edit('', false);\n\t\t\tthis.content = '';\n\t\t} else {\n\t\t\tthis.content = originalBefore;\n\t\t}\n\n\t\tnewChunk.next = this.next;\n\t\tif (newChunk.next) newChunk.next.previous = newChunk;\n\t\tnewChunk.previous = this;\n\t\tthis.next = newChunk;\n\n\t\treturn newChunk;\n\t}\n\n\ttoString() {\n\t\treturn this.intro + this.content + this.outro;\n\t}\n\n\ttrimEnd(rx) {\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.start + trimmed.length).edit('', undefined, true);\n\t\t\t\tif (this.edited) {\n\t\t\t\t\t// save the change, if it has been edited\n\t\t\t\t\tthis.edit(trimmed, this.storeName, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\tif (this.intro.length) return true;\n\t\t}\n\t}\n\n\ttrimStart(rx) {\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tconst newChunk = this.split(this.end - trimmed.length);\n\t\t\t\tif (this.edited) {\n\t\t\t\t\t// save the change, if it has been edited\n\t\t\t\t\tnewChunk.edit(trimmed, this.storeName, true);\n\t\t\t\t}\n\t\t\t\tthis.edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.outro = this.outro.replace(rx, '');\n\t\t\tif (this.outro.length) return true;\n\t\t}\n\t}\n}\n\nfunction getBtoa() {\n\tif (typeof globalThis !== 'undefined' && typeof globalThis.btoa === 'function') {\n\t\treturn (str) => globalThis.btoa(unescape(encodeURIComponent(str)));\n\t} else if (typeof Buffer === 'function') {\n\t\treturn (str) => Buffer.from(str, 'utf-8').toString('base64');\n\t} else {\n\t\treturn () => {\n\t\t\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n\t\t};\n\t}\n}\n\nconst btoa = /*#__PURE__*/ getBtoa();\n\nclass SourceMap {\n\tconstructor(properties) {\n\t\tthis.version = 3;\n\t\tthis.file = properties.file;\n\t\tthis.sources = properties.sources;\n\t\tthis.sourcesContent = properties.sourcesContent;\n\t\tthis.names = properties.names;\n\t\tthis.mappings = encode(properties.mappings);\n\t\tif (typeof properties.x_google_ignoreList !== 'undefined') {\n\t\t\tthis.x_google_ignoreList = properties.x_google_ignoreList;\n\t\t}\n\t\tif (typeof properties.debugId !== 'undefined') {\n\t\t\tthis.debugId = properties.debugId;\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn JSON.stringify(this);\n\t}\n\n\ttoUrl() {\n\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n\t}\n}\n\nfunction guessIndent(code) {\n\tconst lines = code.split('\\n');\n\n\tconst tabbed = lines.filter((line) => /^\\t+/.test(line));\n\tconst spaced = lines.filter((line) => /^ {2,}/.test(line));\n\n\tif (tabbed.length === 0 && spaced.length === 0) {\n\t\treturn null;\n\t}\n\n\t// More lines tabbed than spaced? Assume tabs, and\n\t// default to tabs in the case of a tie (or nothing\n\t// to go on)\n\tif (tabbed.length >= spaced.length) {\n\t\treturn '\\t';\n\t}\n\n\t// Otherwise, we need to guess the multiple\n\tconst min = spaced.reduce((previous, current) => {\n\t\tconst numSpaces = /^ +/.exec(current)[0].length;\n\t\treturn Math.min(numSpaces, previous);\n\t}, Infinity);\n\n\treturn new Array(min + 1).join(' ');\n}\n\nfunction getRelativePath(from, to) {\n\tconst fromParts = from.split(/[/\\\\]/);\n\tconst toParts = to.split(/[/\\\\]/);\n\n\tfromParts.pop(); // get dirname\n\n\twhile (fromParts[0] === toParts[0]) {\n\t\tfromParts.shift();\n\t\ttoParts.shift();\n\t}\n\n\tif (fromParts.length) {\n\t\tlet i = fromParts.length;\n\t\twhile (i--) fromParts[i] = '..';\n\t}\n\n\treturn fromParts.concat(toParts).join('/');\n}\n\nconst toString = Object.prototype.toString;\n\nfunction isObject(thing) {\n\treturn toString.call(thing) === '[object Object]';\n}\n\nfunction getLocator(source) {\n\tconst originalLines = source.split('\\n');\n\tconst lineOffsets = [];\n\n\tfor (let i = 0, pos = 0; i < originalLines.length; i++) {\n\t\tlineOffsets.push(pos);\n\t\tpos += originalLines[i].length + 1;\n\t}\n\n\treturn function locate(index) {\n\t\tlet i = 0;\n\t\tlet j = lineOffsets.length;\n\t\twhile (i < j) {\n\t\t\tconst m = (i + j) >> 1;\n\t\t\tif (index < lineOffsets[m]) {\n\t\t\t\tj = m;\n\t\t\t} else {\n\t\t\t\ti = m + 1;\n\t\t\t}\n\t\t}\n\t\tconst line = i - 1;\n\t\tconst column = index - lineOffsets[line];\n\t\treturn { line, column };\n\t};\n}\n\nconst wordRegex = /\\w/;\n\nclass Mappings {\n\tconstructor(hires) {\n\t\tthis.hires = hires;\n\t\tthis.generatedCodeLine = 0;\n\t\tthis.generatedCodeColumn = 0;\n\t\tthis.raw = [];\n\t\tthis.rawSegments = this.raw[this.generatedCodeLine] = [];\n\t\tthis.pending = null;\n\t}\n\n\taddEdit(sourceIndex, content, loc, nameIndex) {\n\t\tif (content.length) {\n\t\t\tconst contentLengthMinusOne = content.length - 1;\n\t\t\tlet contentLineEnd = content.indexOf('\\n', 0);\n\t\t\tlet previousContentLineEnd = -1;\n\t\t\t// Loop through each line in the content and add a segment, but stop if the last line is empty,\n\t\t\t// else code afterwards would fill one line too many\n\t\t\twhile (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {\n\t\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\t\tif (nameIndex >= 0) {\n\t\t\t\t\tsegment.push(nameIndex);\n\t\t\t\t}\n\t\t\t\tthis.rawSegments.push(segment);\n\n\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\tthis.generatedCodeColumn = 0;\n\n\t\t\t\tpreviousContentLineEnd = contentLineEnd;\n\t\t\t\tcontentLineEnd = content.indexOf('\\n', contentLineEnd + 1);\n\t\t\t}\n\n\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\tif (nameIndex >= 0) {\n\t\t\t\tsegment.push(nameIndex);\n\t\t\t}\n\t\t\tthis.rawSegments.push(segment);\n\n\t\t\tthis.advance(content.slice(previousContentLineEnd + 1));\n\t\t} else if (this.pending) {\n\t\t\tthis.rawSegments.push(this.pending);\n\t\t\tthis.advance(content);\n\t\t}\n\n\t\tthis.pending = null;\n\t}\n\n\taddUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n\t\tlet originalCharIndex = chunk.start;\n\t\tlet first = true;\n\t\t// when iterating each char, check if it's in a word boundary\n\t\tlet charInHiresBoundary = false;\n\n\t\twhile (originalCharIndex < chunk.end) {\n\t\t\tif (original[originalCharIndex] === '\\n') {\n\t\t\t\tloc.line += 1;\n\t\t\t\tloc.column = 0;\n\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\tthis.generatedCodeColumn = 0;\n\t\t\t\tfirst = true;\n\t\t\t\tcharInHiresBoundary = false;\n\t\t\t} else {\n\t\t\t\tif (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n\t\t\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\n\t\t\t\t\tif (this.hires === 'boundary') {\n\t\t\t\t\t\t// in hires \"boundary\", group segments per word boundary than per char\n\t\t\t\t\t\tif (wordRegex.test(original[originalCharIndex])) {\n\t\t\t\t\t\t\t// for first char in the boundary found, start the boundary by pushing a segment\n\t\t\t\t\t\t\tif (!charInHiresBoundary) {\n\t\t\t\t\t\t\t\tthis.rawSegments.push(segment);\n\t\t\t\t\t\t\t\tcharInHiresBoundary = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// for non-word char, end the boundary by pushing a segment\n\t\t\t\t\t\t\tthis.rawSegments.push(segment);\n\t\t\t\t\t\t\tcharInHiresBoundary = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.rawSegments.push(segment);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tloc.column += 1;\n\t\t\t\tthis.generatedCodeColumn += 1;\n\t\t\t\tfirst = false;\n\t\t\t}\n\n\t\t\toriginalCharIndex += 1;\n\t\t}\n\n\t\tthis.pending = null;\n\t}\n\n\tadvance(str) {\n\t\tif (!str) return;\n\n\t\tconst lines = str.split('\\n');\n\n\t\tif (lines.length > 1) {\n\t\t\tfor (let i = 0; i < lines.length - 1; i++) {\n\t\t\t\tthis.generatedCodeLine++;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t}\n\t\t\tthis.generatedCodeColumn = 0;\n\t\t}\n\n\t\tthis.generatedCodeColumn += lines[lines.length - 1].length;\n\t}\n}\n\nconst n = '\\n';\n\nconst warned = {\n\tinsertLeft: false,\n\tinsertRight: false,\n\tstoreName: false,\n};\n\nclass MagicString {\n\tconstructor(string, options = {}) {\n\t\tconst chunk = new Chunk(0, string.length, string);\n\n\t\tObject.defineProperties(this, {\n\t\t\toriginal: { writable: true, value: string },\n\t\t\toutro: { writable: true, value: '' },\n\t\t\tintro: { writable: true, value: '' },\n\t\t\tfirstChunk: { writable: true, value: chunk },\n\t\t\tlastChunk: { writable: true, value: chunk },\n\t\t\tlastSearchedChunk: { writable: true, value: chunk },\n\t\t\tbyStart: { writable: true, value: {} },\n\t\t\tbyEnd: { writable: true, value: {} },\n\t\t\tfilename: { writable: true, value: options.filename },\n\t\t\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n\t\t\tsourcemapLocations: { writable: true, value: new BitSet() },\n\t\t\tstoredNames: { writable: true, value: {} },\n\t\t\tindentStr: { writable: true, value: undefined },\n\t\t\tignoreList: { writable: true, value: options.ignoreList },\n\t\t\toffset: { writable: true, value: options.offset || 0 },\n\t\t});\n\n\t\tthis.byStart[0] = chunk;\n\t\tthis.byEnd[string.length] = chunk;\n\t}\n\n\taddSourcemapLocation(char) {\n\t\tthis.sourcemapLocations.add(char);\n\t}\n\n\tappend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.outro += content;\n\t\treturn this;\n\t}\n\n\tappendLeft(index, content) {\n\t\tindex = index + this.offset;\n\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendLeft(content);\n\t\t} else {\n\t\t\tthis.intro += content;\n\t\t}\n\t\treturn this;\n\t}\n\n\tappendRight(index, content) {\n\t\tindex = index + this.offset;\n\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendRight(content);\n\t\t} else {\n\t\t\tthis.outro += content;\n\t\t}\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst cloned = new MagicString(this.original, { filename: this.filename, offset: this.offset });\n\n\t\tlet originalChunk = this.firstChunk;\n\t\tlet clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());\n\n\t\twhile (originalChunk) {\n\t\t\tcloned.byStart[clonedChunk.start] = clonedChunk;\n\t\t\tcloned.byEnd[clonedChunk.end] = clonedChunk;\n\n\t\t\tconst nextOriginalChunk = originalChunk.next;\n\t\t\tconst nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n\n\t\t\tif (nextClonedChunk) {\n\t\t\t\tclonedChunk.next = nextClonedChunk;\n\t\t\t\tnextClonedChunk.previous = clonedChunk;\n\n\t\t\t\tclonedChunk = nextClonedChunk;\n\t\t\t}\n\n\t\t\toriginalChunk = nextOriginalChunk;\n\t\t}\n\n\t\tcloned.lastChunk = clonedChunk;\n\n\t\tif (this.indentExclusionRanges) {\n\t\t\tcloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n\t\t}\n\n\t\tcloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n\n\t\tcloned.intro = this.intro;\n\t\tcloned.outro = this.outro;\n\n\t\treturn cloned;\n\t}\n\n\tgenerateDecodedMap(options) {\n\t\toptions = options || {};\n\n\t\tconst sourceIndex = 0;\n\t\tconst names = Object.keys(this.storedNames);\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tconst locate = getLocator(this.original);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.firstChunk.eachNext((chunk) => {\n\t\t\tconst loc = locate(chunk.start);\n\n\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tmappings.addEdit(\n\t\t\t\t\tsourceIndex,\n\t\t\t\t\tchunk.content,\n\t\t\t\t\tloc,\n\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tmappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\n\t\t\t}\n\n\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t});\n\n\t\tif (this.outro) {\n\t\t\tmappings.advance(this.outro);\n\t\t}\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : undefined,\n\t\t\tsources: [\n\t\t\t\toptions.source ? getRelativePath(options.file || '', options.source) : options.file || '',\n\t\t\t],\n\t\t\tsourcesContent: options.includeContent ? [this.original] : undefined,\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t\tx_google_ignoreList: this.ignoreList ? [sourceIndex] : undefined,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\t_ensureindentStr() {\n\t\tif (this.indentStr === undefined) {\n\t\t\tthis.indentStr = guessIndent(this.original);\n\t\t}\n\t}\n\n\t_getRawIndentString() {\n\t\tthis._ensureindentStr();\n\t\treturn this.indentStr;\n\t}\n\n\tgetIndentString() {\n\t\tthis._ensureindentStr();\n\t\treturn this.indentStr === null ? '\\t' : this.indentStr;\n\t}\n\n\tindent(indentStr, options) {\n\t\tconst pattern = /^[^\\r\\n]/gm;\n\n\t\tif (isObject(indentStr)) {\n\t\t\toptions = indentStr;\n\t\t\tindentStr = undefined;\n\t\t}\n\n\t\tif (indentStr === undefined) {\n\t\t\tthis._ensureindentStr();\n\t\t\tindentStr = this.indentStr || '\\t';\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\toptions = options || {};\n\n\t\t// Process exclusion ranges\n\t\tconst isExcluded = {};\n\n\t\tif (options.exclude) {\n\t\t\tconst exclusions =\n\t\t\t\ttypeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n\t\t\texclusions.forEach((exclusion) => {\n\t\t\t\tfor (let i = exclusion[0]; i < exclusion[1]; i += 1) {\n\t\t\t\t\tisExcluded[i] = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tlet shouldIndentNextCharacter = options.indentStart !== false;\n\t\tconst replacer = (match) => {\n\t\t\tif (shouldIndentNextCharacter) return `${indentStr}${match}`;\n\t\t\tshouldIndentNextCharacter = true;\n\t\t\treturn match;\n\t\t};\n\n\t\tthis.intro = this.intro.replace(pattern, replacer);\n\n\t\tlet charIndex = 0;\n\t\tlet chunk = this.firstChunk;\n\n\t\twhile (chunk) {\n\t\t\tconst end = chunk.end;\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\tchunk.content = chunk.content.replace(pattern, replacer);\n\n\t\t\t\t\tif (chunk.content.length) {\n\t\t\t\t\t\tshouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcharIndex = chunk.start;\n\n\t\t\t\twhile (charIndex < end) {\n\t\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\t\tconst char = this.original[charIndex];\n\n\t\t\t\t\t\tif (char === '\\n') {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = true;\n\t\t\t\t\t\t} else if (char !== '\\r' && shouldIndentNextCharacter) {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = false;\n\n\t\t\t\t\t\t\tif (charIndex === chunk.start) {\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis._splitChunk(chunk, charIndex);\n\t\t\t\t\t\t\t\tchunk = chunk.next;\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcharIndex += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcharIndex = chunk.end;\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tthis.outro = this.outro.replace(pattern, replacer);\n\n\t\treturn this;\n\t}\n\n\tinsert() {\n\t\tthrow new Error(\n\t\t\t'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)',\n\t\t);\n\t}\n\n\tinsertLeft(index, content) {\n\t\tif (!warned.insertLeft) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead',\n\t\t\t);\n\t\t\twarned.insertLeft = true;\n\t\t}\n\n\t\treturn this.appendLeft(index, content);\n\t}\n\n\tinsertRight(index, content) {\n\t\tif (!warned.insertRight) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead',\n\t\t\t);\n\t\t\twarned.insertRight = true;\n\t\t}\n\n\t\treturn this.prependRight(index, content);\n\t}\n\n\tmove(start, end, index) {\n\t\tstart = start + this.offset;\n\t\tend = end + this.offset;\n\t\tindex = index + this.offset;\n\n\t\tif (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\t\tthis._split(index);\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tconst oldLeft = first.previous;\n\t\tconst oldRight = last.next;\n\n\t\tconst newRight = this.byStart[index];\n\t\tif (!newRight && last === this.lastChunk) return this;\n\t\tconst newLeft = newRight ? newRight.previous : this.lastChunk;\n\n\t\tif (oldLeft) oldLeft.next = oldRight;\n\t\tif (oldRight) oldRight.previous = oldLeft;\n\n\t\tif (newLeft) newLeft.next = first;\n\t\tif (newRight) newRight.previous = last;\n\n\t\tif (!first.previous) this.firstChunk = last.next;\n\t\tif (!last.next) {\n\t\t\tthis.lastChunk = first.previous;\n\t\t\tthis.lastChunk.next = null;\n\t\t}\n\n\t\tfirst.previous = newLeft;\n\t\tlast.next = newRight || null;\n\n\t\tif (!newLeft) this.firstChunk = first;\n\t\tif (!newRight) this.lastChunk = last;\n\t\treturn this;\n\t}\n\n\toverwrite(start, end, content, options) {\n\t\toptions = options || {};\n\t\treturn this.update(start, end, content, { ...options, overwrite: !options.contentOnly });\n\t}\n\n\tupdate(start, end, content, options) {\n\t\tstart = start + this.offset;\n\t\tend = end + this.offset;\n\n\t\tif (typeof content !== 'string') throw new TypeError('replacement content must be a string');\n\n\t\tif (this.original.length !== 0) {\n\t\t\twhile (start < 0) start += this.original.length;\n\t\t\twhile (end < 0) end += this.original.length;\n\t\t}\n\n\t\tif (end > this.original.length) throw new Error('end is out of bounds');\n\t\tif (start === end)\n\t\t\tthrow new Error(\n\t\t\t\t'Cannot overwrite a zero-length range – use appendLeft or prependRight instead',\n\t\t\t);\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tif (options === true) {\n\t\t\tif (!warned.storeName) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string',\n\t\t\t\t);\n\t\t\t\twarned.storeName = true;\n\t\t\t}\n\n\t\t\toptions = { storeName: true };\n\t\t}\n\t\tconst storeName = options !== undefined ? options.storeName : false;\n\t\tconst overwrite = options !== undefined ? options.overwrite : false;\n\n\t\tif (storeName) {\n\t\t\tconst original = this.original.slice(start, end);\n\t\t\tObject.defineProperty(this.storedNames, original, {\n\t\t\t\twritable: true,\n\t\t\t\tvalue: true,\n\t\t\t\tenumerable: true,\n\t\t\t});\n\t\t}\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tif (first) {\n\t\t\tlet chunk = first;\n\t\t\twhile (chunk !== last) {\n\t\t\t\tif (chunk.next !== this.byStart[chunk.end]) {\n\t\t\t\t\tthrow new Error('Cannot overwrite across a split point');\n\t\t\t\t}\n\t\t\t\tchunk = chunk.next;\n\t\t\t\tchunk.edit('', false);\n\t\t\t}\n\n\t\t\tfirst.edit(content, storeName, !overwrite);\n\t\t} else {\n\t\t\t// must be inserting at the end\n\t\t\tconst newChunk = new Chunk(start, end, '').edit(content, storeName);\n\n\t\t\t// TODO last chunk in the array may not be the last chunk, if it's moved...\n\t\t\tlast.next = newChunk;\n\t\t\tnewChunk.previous = last;\n\t\t}\n\t\treturn this;\n\t}\n\n\tprepend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.intro = content + this.intro;\n\t\treturn this;\n\t}\n\n\tprependLeft(index, content) {\n\t\tindex = index + this.offset;\n\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependLeft(content);\n\t\t} else {\n\t\t\tthis.intro = content + this.intro;\n\t\t}\n\t\treturn this;\n\t}\n\n\tprependRight(index, content) {\n\t\tindex = index + this.offset;\n\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependRight(content);\n\t\t} else {\n\t\t\tthis.outro = content + this.outro;\n\t\t}\n\t\treturn this;\n\t}\n\n\tremove(start, end) {\n\t\tstart = start + this.offset;\n\t\tend = end + this.offset;\n\n\t\tif (this.original.length !== 0) {\n\t\t\twhile (start < 0) start += this.original.length;\n\t\t\twhile (end < 0) end += this.original.length;\n\t\t}\n\n\t\tif (start === end) return this;\n\n\t\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n\t\tif (start > end) throw new Error('end must be greater than start');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tlet chunk = this.byStart[start];\n\n\t\twhile (chunk) {\n\t\t\tchunk.intro = '';\n\t\t\tchunk.outro = '';\n\t\t\tchunk.edit('');\n\n\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t}\n\t\treturn this;\n\t}\n\n\treset(start, end) {\n\t\tstart = start + this.offset;\n\t\tend = end + this.offset;\n\n\t\tif (this.original.length !== 0) {\n\t\t\twhile (start < 0) start += this.original.length;\n\t\t\twhile (end < 0) end += this.original.length;\n\t\t}\n\n\t\tif (start === end) return this;\n\n\t\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n\t\tif (start > end) throw new Error('end must be greater than start');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tlet chunk = this.byStart[start];\n\n\t\twhile (chunk) {\n\t\t\tchunk.reset();\n\n\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t}\n\t\treturn this;\n\t}\n\n\tlastChar() {\n\t\tif (this.outro.length) return this.outro[this.outro.length - 1];\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\n\t\t\tif (chunk.content.length) return chunk.content[chunk.content.length - 1];\n\t\t\tif (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\n\t\t} while ((chunk = chunk.previous));\n\t\tif (this.intro.length) return this.intro[this.intro.length - 1];\n\t\treturn '';\n\t}\n\n\tlastLine() {\n\t\tlet lineIndex = this.outro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\n\t\tlet lineStr = this.outro;\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length > 0) {\n\t\t\t\tlineIndex = chunk.outro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.outro + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.content.length > 0) {\n\t\t\t\tlineIndex = chunk.content.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.content + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.intro.length > 0) {\n\t\t\t\tlineIndex = chunk.intro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.intro + lineStr;\n\t\t\t}\n\t\t} while ((chunk = chunk.previous));\n\t\tlineIndex = this.intro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\n\t\treturn this.intro + lineStr;\n\t}\n\n\tslice(start = 0, end = this.original.length - this.offset) {\n\t\tstart = start + this.offset;\n\t\tend = end + this.offset;\n\n\t\tif (this.original.length !== 0) {\n\t\t\twhile (start < 0) start += this.original.length;\n\t\t\twhile (end < 0) end += this.original.length;\n\t\t}\n\n\t\tlet result = '';\n\n\t\t// find start chunk\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk && (chunk.start > start || chunk.end <= start)) {\n\t\t\t// found end chunk before start\n\t\t\tif (chunk.start < end && chunk.end >= end) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tif (chunk && chunk.edited && chunk.start !== start)\n\t\t\tthrow new Error(`Cannot use replaced character ${start} as slice start anchor.`);\n\n\t\tconst startChunk = chunk;\n\t\twhile (chunk) {\n\t\t\tif (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n\t\t\t\tresult += chunk.intro;\n\t\t\t}\n\n\t\t\tconst containsEnd = chunk.start < end && chunk.end >= end;\n\t\t\tif (containsEnd && chunk.edited && chunk.end !== end)\n\t\t\t\tthrow new Error(`Cannot use replaced character ${end} as slice end anchor.`);\n\n\t\t\tconst sliceStart = startChunk === chunk ? start - chunk.start : 0;\n\t\t\tconst sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n\n\t\t\tresult += chunk.content.slice(sliceStart, sliceEnd);\n\n\t\t\tif (chunk.outro && (!containsEnd || chunk.end === end)) {\n\t\t\t\tresult += chunk.outro;\n\t\t\t}\n\n\t\t\tif (containsEnd) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// TODO deprecate this? not really very useful\n\tsnip(start, end) {\n\t\tconst clone = this.clone();\n\t\tclone.remove(0, start);\n\t\tclone.remove(end, clone.original.length);\n\n\t\treturn clone;\n\t}\n\n\t_split(index) {\n\t\tif (this.byStart[index] || this.byEnd[index]) return;\n\n\t\tlet chunk = this.lastSearchedChunk;\n\t\tlet previousChunk = chunk;\n\t\tconst searchForward = index > chunk.end;\n\n\t\twhile (chunk) {\n\t\t\tif (chunk.contains(index)) return this._splitChunk(chunk, index);\n\n\t\t\tchunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n\n\t\t\t// Prevent infinite loop (e.g. via empty chunks, where start === end)\n\t\t\tif (chunk === previousChunk) return;\n\n\t\t\tpreviousChunk = chunk;\n\t\t}\n\t}\n\n\t_splitChunk(chunk, index) {\n\t\tif (chunk.edited && chunk.content.length) {\n\t\t\t// zero-length edited chunks are a special case (overlapping replacements)\n\t\t\tconst loc = getLocator(this.original)(index);\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – \"${chunk.original}\")`,\n\t\t\t);\n\t\t}\n\n\t\tconst newChunk = chunk.split(index);\n\n\t\tthis.byEnd[index] = chunk;\n\t\tthis.byStart[index] = newChunk;\n\t\tthis.byEnd[newChunk.end] = newChunk;\n\n\t\tif (chunk === this.lastChunk) this.lastChunk = newChunk;\n\n\t\tthis.lastSearchedChunk = chunk;\n\t\treturn true;\n\t}\n\n\ttoString() {\n\t\tlet str = this.intro;\n\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk) {\n\t\t\tstr += chunk.toString();\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn str + this.outro;\n\t}\n\n\tisEmpty() {\n\t\tlet chunk = this.firstChunk;\n\t\tdo {\n\t\t\tif (\n\t\t\t\t(chunk.intro.length && chunk.intro.trim()) ||\n\t\t\t\t(chunk.content.length && chunk.content.trim()) ||\n\t\t\t\t(chunk.outro.length && chunk.outro.trim())\n\t\t\t)\n\t\t\t\treturn false;\n\t\t} while ((chunk = chunk.next));\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\tlet chunk = this.firstChunk;\n\t\tlet length = 0;\n\t\tdo {\n\t\t\tlength += chunk.intro.length + chunk.content.length + chunk.outro.length;\n\t\t} while ((chunk = chunk.next));\n\t\treturn length;\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimEndAborted(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tlet chunk = this.lastChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimEnd(rx);\n\n\t\t\t// if chunk was trimmed, we have a new lastChunk\n\t\t\tif (chunk.end !== end) {\n\t\t\t\tif (this.lastChunk === chunk) {\n\t\t\t\t\tthis.lastChunk = chunk.next;\n\t\t\t\t}\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.previous;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimEnd(charType) {\n\t\tthis.trimEndAborted(charType);\n\t\treturn this;\n\t}\n\ttrimStartAborted(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tlet chunk = this.firstChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimStart(rx);\n\n\t\t\tif (chunk.end !== end) {\n\t\t\t\t// special case...\n\t\t\t\tif (chunk === this.lastChunk) this.lastChunk = chunk.next;\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.next;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimStart(charType) {\n\t\tthis.trimStartAborted(charType);\n\t\treturn this;\n\t}\n\n\thasChanged() {\n\t\treturn this.original !== this.toString();\n\t}\n\n\t_replaceRegexp(searchValue, replacement) {\n\t\tfunction getReplacement(match, str) {\n\t\t\tif (typeof replacement === 'string') {\n\t\t\t\treturn replacement.replace(/\\$(\\$|&|\\d+)/g, (_, i) => {\n\t\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter\n\t\t\t\t\tif (i === '$') return '$';\n\t\t\t\t\tif (i === '&') return match[0];\n\t\t\t\t\tconst num = +i;\n\t\t\t\t\tif (num < match.length) return match[+i];\n\t\t\t\t\treturn `$${i}`;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn replacement(...match, match.index, str, match.groups);\n\t\t\t}\n\t\t}\n\t\tfunction matchAll(re, str) {\n\t\t\tlet match;\n\t\t\tconst matches = [];\n\t\t\twhile ((match = re.exec(str))) {\n\t\t\t\tmatches.push(match);\n\t\t\t}\n\t\t\treturn matches;\n\t\t}\n\t\tif (searchValue.global) {\n\t\t\tconst matches = matchAll(searchValue, this.original);\n\t\t\tmatches.forEach((match) => {\n\t\t\t\tif (match.index != null) {\n\t\t\t\t\tconst replacement = getReplacement(match, this.original);\n\t\t\t\t\tif (replacement !== match[0]) {\n\t\t\t\t\t\tthis.overwrite(match.index, match.index + match[0].length, replacement);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tconst match = this.original.match(searchValue);\n\t\t\tif (match && match.index != null) {\n\t\t\t\tconst replacement = getReplacement(match, this.original);\n\t\t\t\tif (replacement !== match[0]) {\n\t\t\t\t\tthis.overwrite(match.index, match.index + match[0].length, replacement);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t_replaceString(string, replacement) {\n\t\tconst { original } = this;\n\t\tconst index = original.indexOf(string);\n\n\t\tif (index !== -1) {\n\t\t\tif (typeof replacement === 'function') {\n\t\t\t\treplacement = replacement(string, index, original);\n\t\t\t}\n\t\t\tif (string !== replacement) {\n\t\t\t\tthis.overwrite(index, index + string.length, replacement);\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\treplace(searchValue, replacement) {\n\t\tif (typeof searchValue === 'string') {\n\t\t\treturn this._replaceString(searchValue, replacement);\n\t\t}\n\n\t\treturn this._replaceRegexp(searchValue, replacement);\n\t}\n\n\t_replaceAllString(string, replacement) {\n\t\tconst { original } = this;\n\t\tconst stringLength = string.length;\n\t\tfor (\n\t\t\tlet index = original.indexOf(string);\n\t\t\tindex !== -1;\n\t\t\tindex = original.indexOf(string, index + stringLength)\n\t\t) {\n\t\t\tconst previous = original.slice(index, index + stringLength);\n\t\t\tlet _replacement = replacement;\n\t\t\tif (typeof replacement === 'function') {\n\t\t\t\t_replacement = replacement(previous, index, original);\n\t\t\t}\n\t\t\tif (previous !== _replacement) this.overwrite(index, index + stringLength, _replacement);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\treplaceAll(searchValue, replacement) {\n\t\tif (typeof searchValue === 'string') {\n\t\t\treturn this._replaceAllString(searchValue, replacement);\n\t\t}\n\n\t\tif (!searchValue.global) {\n\t\t\tthrow new TypeError(\n\t\t\t\t'MagicString.prototype.replaceAll called with a non-global RegExp argument',\n\t\t\t);\n\t\t}\n\n\t\treturn this._replaceRegexp(searchValue, replacement);\n\t}\n}\n\nconst hasOwnProp = Object.prototype.hasOwnProperty;\n\nclass Bundle {\n\tconstructor(options = {}) {\n\t\tthis.intro = options.intro || '';\n\t\tthis.separator = options.separator !== undefined ? options.separator : '\\n';\n\t\tthis.sources = [];\n\t\tthis.uniqueSources = [];\n\t\tthis.uniqueSourceIndexByFilename = {};\n\t}\n\n\taddSource(source) {\n\t\tif (source instanceof MagicString) {\n\t\t\treturn this.addSource({\n\t\t\t\tcontent: source,\n\t\t\t\tfilename: source.filename,\n\t\t\t\tseparator: this.separator,\n\t\t\t});\n\t\t}\n\n\t\tif (!isObject(source) || !source.content) {\n\t\t\tthrow new Error(\n\t\t\t\t'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`',\n\t\t\t);\n\t\t}\n\n\t\t['filename', 'ignoreList', 'indentExclusionRanges', 'separator'].forEach((option) => {\n\t\t\tif (!hasOwnProp.call(source, option)) source[option] = source.content[option];\n\t\t});\n\n\t\tif (source.separator === undefined) {\n\t\t\t// TODO there's a bunch of this sort of thing, needs cleaning up\n\t\t\tsource.separator = this.separator;\n\t\t}\n\n\t\tif (source.filename) {\n\t\t\tif (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n\t\t\t\tthis.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n\t\t\t\tthis.uniqueSources.push({ filename: source.filename, content: source.content.original });\n\t\t\t} else {\n\t\t\t\tconst uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n\t\t\t\tif (source.content.original !== uniqueSource.content) {\n\t\t\t\t\tthrow new Error(`Illegal source: same filename (${source.filename}), different contents`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.sources.push(source);\n\t\treturn this;\n\t}\n\n\tappend(str, options) {\n\t\tthis.addSource({\n\t\t\tcontent: new MagicString(str),\n\t\t\tseparator: (options && options.separator) || '',\n\t\t});\n\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst bundle = new Bundle({\n\t\t\tintro: this.intro,\n\t\t\tseparator: this.separator,\n\t\t});\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tbundle.addSource({\n\t\t\t\tfilename: source.filename,\n\t\t\t\tcontent: source.content.clone(),\n\t\t\t\tseparator: source.separator,\n\t\t\t});\n\t\t});\n\n\t\treturn bundle;\n\t}\n\n\tgenerateDecodedMap(options = {}) {\n\t\tconst names = [];\n\t\tlet x_google_ignoreList = undefined;\n\t\tthis.sources.forEach((source) => {\n\t\t\tObject.keys(source.content.storedNames).forEach((name) => {\n\t\t\t\tif (!~names.indexOf(name)) names.push(name);\n\t\t\t});\n\t\t});\n\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tif (i > 0) {\n\t\t\t\tmappings.advance(this.separator);\n\t\t\t}\n\n\t\t\tconst sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;\n\t\t\tconst magicString = source.content;\n\t\t\tconst locate = getLocator(magicString.original);\n\n\t\t\tif (magicString.intro) {\n\t\t\t\tmappings.advance(magicString.intro);\n\t\t\t}\n\n\t\t\tmagicString.firstChunk.eachNext((chunk) => {\n\t\t\t\tconst loc = locate(chunk.start);\n\n\t\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\t\tif (source.filename) {\n\t\t\t\t\tif (chunk.edited) {\n\t\t\t\t\t\tmappings.addEdit(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk.content,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1,\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmappings.addUneditedChunk(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tmagicString.original,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tmagicString.sourcemapLocations,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmappings.advance(chunk.content);\n\t\t\t\t}\n\n\t\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t\t});\n\n\t\t\tif (magicString.outro) {\n\t\t\t\tmappings.advance(magicString.outro);\n\t\t\t}\n\n\t\t\tif (source.ignoreList && sourceIndex !== -1) {\n\t\t\t\tif (x_google_ignoreList === undefined) {\n\t\t\t\t\tx_google_ignoreList = [];\n\t\t\t\t}\n\t\t\t\tx_google_ignoreList.push(sourceIndex);\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : undefined,\n\t\t\tsources: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.file ? getRelativePath(options.file, source.filename) : source.filename;\n\t\t\t}),\n\t\t\tsourcesContent: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.includeContent ? source.content : null;\n\t\t\t}),\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t\tx_google_ignoreList,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\tgetIndentString() {\n\t\tconst indentStringCounts = {};\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tconst indentStr = source.content._getRawIndentString();\n\n\t\t\tif (indentStr === null) return;\n\n\t\t\tif (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\n\t\t\tindentStringCounts[indentStr] += 1;\n\t\t});\n\n\t\treturn (\n\t\t\tObject.keys(indentStringCounts).sort((a, b) => {\n\t\t\t\treturn indentStringCounts[a] - indentStringCounts[b];\n\t\t\t})[0] || '\\t'\n\t\t);\n\t}\n\n\tindent(indentStr) {\n\t\tif (!arguments.length) {\n\t\t\tindentStr = this.getIndentString();\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\tlet trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\tconst indentStart = trailingNewline || (i > 0 && /\\r?\\n$/.test(separator));\n\n\t\t\tsource.content.indent(indentStr, {\n\t\t\t\texclude: source.indentExclusionRanges,\n\t\t\t\tindentStart, //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\t\t\t});\n\n\t\t\ttrailingNewline = source.content.lastChar() === '\\n';\n\t\t});\n\n\t\tif (this.intro) {\n\t\t\tthis.intro =\n\t\t\t\tindentStr +\n\t\t\t\tthis.intro.replace(/^[^\\n]/gm, (match, index) => {\n\t\t\t\t\treturn index > 0 ? indentStr + match : match;\n\t\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprepend(str) {\n\t\tthis.intro = str + this.intro;\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\tconst body = this.sources\n\t\t\t.map((source, i) => {\n\t\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\t\tconst str = (i > 0 ? separator : '') + source.content.toString();\n\n\t\t\t\treturn str;\n\t\t\t})\n\t\t\t.join('');\n\n\t\treturn this.intro + body;\n\t}\n\n\tisEmpty() {\n\t\tif (this.intro.length && this.intro.trim()) return false;\n\t\tif (this.sources.some((source) => !source.content.isEmpty())) return false;\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\treturn this.sources.reduce(\n\t\t\t(length, source) => length + source.content.length(),\n\t\t\tthis.intro.length,\n\t\t);\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimStart(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\t\tthis.intro = this.intro.replace(rx, '');\n\n\t\tif (!this.intro) {\n\t\t\tlet source;\n\t\t\tlet i = 0;\n\n\t\t\tdo {\n\t\t\t\tsource = this.sources[i++];\n\t\t\t\tif (!source) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (!source.content.trimStartAborted(charType));\n\t\t}\n\n\t\treturn this;\n\t}\n\n\ttrimEnd(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tlet source;\n\t\tlet i = this.sources.length - 1;\n\n\t\tdo {\n\t\t\tsource = this.sources[i--];\n\t\t\tif (!source) {\n\t\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (!source.content.trimEndAborted(charType));\n\n\t\treturn this;\n\t}\n}\n\nexport { Bundle, SourceMap, MagicString as default };\n//# sourceMappingURL=magic-string.es.mjs.map\n","export const balanced = (a, b, str) => {\n    const ma = a instanceof RegExp ? maybeMatch(a, str) : a;\n    const mb = b instanceof RegExp ? maybeMatch(b, str) : b;\n    const r = ma !== null && mb != null && range(ma, mb, str);\n    return (r && {\n        start: r[0],\n        end: r[1],\n        pre: str.slice(0, r[0]),\n        body: str.slice(r[0] + ma.length, r[1]),\n        post: str.slice(r[1] + mb.length),\n    });\n};\nconst maybeMatch = (reg, str) => {\n    const m = str.match(reg);\n    return m ? m[0] : null;\n};\nexport const range = (a, b, str) => {\n    let begs, beg, left, right = undefined, result;\n    let ai = str.indexOf(a);\n    let bi = str.indexOf(b, ai + 1);\n    let i = ai;\n    if (ai >= 0 && bi > 0) {\n        if (a === b) {\n            return [ai, bi];\n        }\n        begs = [];\n        left = str.length;\n        while (i >= 0 && !result) {\n            if (i === ai) {\n                begs.push(i);\n                ai = str.indexOf(a, i + 1);\n            }\n            else if (begs.length === 1) {\n                const r = begs.pop();\n                if (r !== undefined)\n                    result = [r, bi];\n            }\n            else {\n                beg = begs.pop();\n                if (beg !== undefined && beg < left) {\n                    left = beg;\n                    right = bi;\n                }\n                bi = str.indexOf(b, i + 1);\n            }\n            i = ai < bi && ai >= 0 ? ai : bi;\n        }\n        if (begs.length && right !== undefined) {\n            result = [left, right];\n        }\n    }\n    return result;\n};\n//# sourceMappingURL=index.js.map","import { balanced } from '@isaacs/balanced-match';\nconst escSlash = '\\0SLASH' + Math.random() + '\\0';\nconst escOpen = '\\0OPEN' + Math.random() + '\\0';\nconst escClose = '\\0CLOSE' + Math.random() + '\\0';\nconst escComma = '\\0COMMA' + Math.random() + '\\0';\nconst escPeriod = '\\0PERIOD' + Math.random() + '\\0';\nconst escSlashPattern = new RegExp(escSlash, 'g');\nconst escOpenPattern = new RegExp(escOpen, 'g');\nconst escClosePattern = new RegExp(escClose, 'g');\nconst escCommaPattern = new RegExp(escComma, 'g');\nconst escPeriodPattern = new RegExp(escPeriod, 'g');\nconst slashPattern = /\\\\\\\\/g;\nconst openPattern = /\\\\{/g;\nconst closePattern = /\\\\}/g;\nconst commaPattern = /\\\\,/g;\nconst periodPattern = /\\\\./g;\nfunction numeric(str) {\n    return !isNaN(str) ? parseInt(str, 10) : str.charCodeAt(0);\n}\nfunction escapeBraces(str) {\n    return str\n        .replace(slashPattern, escSlash)\n        .replace(openPattern, escOpen)\n        .replace(closePattern, escClose)\n        .replace(commaPattern, escComma)\n        .replace(periodPattern, escPeriod);\n}\nfunction unescapeBraces(str) {\n    return str\n        .replace(escSlashPattern, '\\\\')\n        .replace(escOpenPattern, '{')\n        .replace(escClosePattern, '}')\n        .replace(escCommaPattern, ',')\n        .replace(escPeriodPattern, '.');\n}\n/**\n * Basically just str.split(\",\"), but handling cases\n * where we have nested braced sections, which should be\n * treated as individual members, like {a,{b,c},d}\n */\nfunction parseCommaParts(str) {\n    if (!str) {\n        return [''];\n    }\n    const parts = [];\n    const m = balanced('{', '}', str);\n    if (!m) {\n        return str.split(',');\n    }\n    const { pre, body, post } = m;\n    const p = pre.split(',');\n    p[p.length - 1] += '{' + body + '}';\n    const postParts = parseCommaParts(post);\n    if (post.length) {\n        ;\n        p[p.length - 1] += postParts.shift();\n        p.push.apply(p, postParts);\n    }\n    parts.push.apply(parts, p);\n    return parts;\n}\nexport function expand(str) {\n    if (!str) {\n        return [];\n    }\n    // I don't know why Bash 4.3 does this, but it does.\n    // Anything starting with {} will have the first two bytes preserved\n    // but *only* at the top level, so {},a}b will not expand to anything,\n    // but a{},b}c will be expanded to [a}c,abc].\n    // One could argue that this is a bug in Bash, but since the goal of\n    // this module is to match Bash's rules, we escape a leading {}\n    if (str.slice(0, 2) === '{}') {\n        str = '\\\\{\\\\}' + str.slice(2);\n    }\n    return expand_(escapeBraces(str), true).map(unescapeBraces);\n}\nfunction embrace(str) {\n    return '{' + str + '}';\n}\nfunction isPadded(el) {\n    return /^-?0\\d/.test(el);\n}\nfunction lte(i, y) {\n    return i <= y;\n}\nfunction gte(i, y) {\n    return i >= y;\n}\nfunction expand_(str, isTop) {\n    /** @type {string[]} */\n    const expansions = [];\n    const m = balanced('{', '}', str);\n    if (!m)\n        return [str];\n    // no need to expand pre, since it is guaranteed to be free of brace-sets\n    const pre = m.pre;\n    const post = m.post.length ? expand_(m.post, false) : [''];\n    if (/\\$$/.test(m.pre)) {\n        for (let k = 0; k < post.length; k++) {\n            const expansion = pre + '{' + m.body + '}' + post[k];\n            expansions.push(expansion);\n        }\n    }\n    else {\n        const isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n        const isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n        const isSequence = isNumericSequence || isAlphaSequence;\n        const isOptions = m.body.indexOf(',') >= 0;\n        if (!isSequence && !isOptions) {\n            // {a},b}\n            if (m.post.match(/,(?!,).*\\}/)) {\n                str = m.pre + '{' + m.body + escClose + m.post;\n                return expand_(str);\n            }\n            return [str];\n        }\n        let n;\n        if (isSequence) {\n            n = m.body.split(/\\.\\./);\n        }\n        else {\n            n = parseCommaParts(m.body);\n            if (n.length === 1 && n[0] !== undefined) {\n                // x{{a,b}}y ==> x{a}y x{b}y\n                n = expand_(n[0], false).map(embrace);\n                //XXX is this necessary? Can't seem to hit it in tests.\n                /* c8 ignore start */\n                if (n.length === 1) {\n                    return post.map(p => m.pre + n[0] + p);\n                }\n                /* c8 ignore stop */\n            }\n        }\n        // at this point, n is the parts, and we know it's not a comma set\n        // with a single entry.\n        let N;\n        if (isSequence && n[0] !== undefined && n[1] !== undefined) {\n            const x = numeric(n[0]);\n            const y = numeric(n[1]);\n            const width = Math.max(n[0].length, n[1].length);\n            let incr = n.length === 3 && n[2] !== undefined ? Math.abs(numeric(n[2])) : 1;\n            let test = lte;\n            const reverse = y < x;\n            if (reverse) {\n                incr *= -1;\n                test = gte;\n            }\n            const pad = n.some(isPadded);\n            N = [];\n            for (let i = x; test(i, y); i += incr) {\n                let c;\n                if (isAlphaSequence) {\n                    c = String.fromCharCode(i);\n                    if (c === '\\\\') {\n                        c = '';\n                    }\n                }\n                else {\n                    c = String(i);\n                    if (pad) {\n                        const need = width - c.length;\n                        if (need > 0) {\n                            const z = new Array(need + 1).join('0');\n                            if (i < 0) {\n                                c = '-' + z + c.slice(1);\n                            }\n                            else {\n                                c = z + c;\n                            }\n                        }\n                    }\n                }\n                N.push(c);\n            }\n        }\n        else {\n            N = [];\n            for (let j = 0; j < n.length; j++) {\n                N.push.apply(N, expand_(n[j], false));\n            }\n        }\n        for (let j = 0; j < N.length; j++) {\n            for (let k = 0; k < post.length; k++) {\n                const expansion = pre + N[j] + post[k];\n                if (!isTop || isSequence || expansion) {\n                    expansions.push(expansion);\n                }\n            }\n        }\n    }\n    return expansions;\n}\n//# sourceMappingURL=index.js.map","const MAX_PATTERN_LENGTH = 1024 * 64;\nexport const assertValidPattern = (pattern) => {\n    if (typeof pattern !== 'string') {\n        throw new TypeError('invalid pattern');\n    }\n    if (pattern.length > MAX_PATTERN_LENGTH) {\n        throw new TypeError('pattern is too long');\n    }\n};\n//# sourceMappingURL=assert-valid-pattern.js.map","// translate the various posix character classes into unicode properties\n// this works across all unicode locales\n// { <posix class>: [<translation>, /u flag required, negated]\nconst posixClasses = {\n    '[:alnum:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}', true],\n    '[:alpha:]': ['\\\\p{L}\\\\p{Nl}', true],\n    '[:ascii:]': ['\\\\x' + '00-\\\\x' + '7f', false],\n    '[:blank:]': ['\\\\p{Zs}\\\\t', true],\n    '[:cntrl:]': ['\\\\p{Cc}', true],\n    '[:digit:]': ['\\\\p{Nd}', true],\n    '[:graph:]': ['\\\\p{Z}\\\\p{C}', true, true],\n    '[:lower:]': ['\\\\p{Ll}', true],\n    '[:print:]': ['\\\\p{C}', true],\n    '[:punct:]': ['\\\\p{P}', true],\n    '[:space:]': ['\\\\p{Z}\\\\t\\\\r\\\\n\\\\v\\\\f', true],\n    '[:upper:]': ['\\\\p{Lu}', true],\n    '[:word:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}\\\\p{Pc}', true],\n    '[:xdigit:]': ['A-Fa-f0-9', false],\n};\n// only need to escape a few things inside of brace expressions\n// escapes: [ \\ ] -\nconst braceEscape = (s) => s.replace(/[[\\]\\\\-]/g, '\\\\$&');\n// escape all regexp magic characters\nconst regexpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// everything has already been escaped, we just have to join\nconst rangesToString = (ranges) => ranges.join('');\n// takes a glob string at a posix brace expression, and returns\n// an equivalent regular expression source, and boolean indicating\n// whether the /u flag needs to be applied, and the number of chars\n// consumed to parse the character class.\n// This also removes out of order ranges, and returns ($.) if the\n// entire class just no good.\nexport const parseClass = (glob, position) => {\n    const pos = position;\n    /* c8 ignore start */\n    if (glob.charAt(pos) !== '[') {\n        throw new Error('not in a brace expression');\n    }\n    /* c8 ignore stop */\n    const ranges = [];\n    const negs = [];\n    let i = pos + 1;\n    let sawStart = false;\n    let uflag = false;\n    let escaping = false;\n    let negate = false;\n    let endPos = pos;\n    let rangeStart = '';\n    WHILE: while (i < glob.length) {\n        const c = glob.charAt(i);\n        if ((c === '!' || c === '^') && i === pos + 1) {\n            negate = true;\n            i++;\n            continue;\n        }\n        if (c === ']' && sawStart && !escaping) {\n            endPos = i + 1;\n            break;\n        }\n        sawStart = true;\n        if (c === '\\\\') {\n            if (!escaping) {\n                escaping = true;\n                i++;\n                continue;\n            }\n            // escaped \\ char, fall through and treat like normal char\n        }\n        if (c === '[' && !escaping) {\n            // either a posix class, a collation equivalent, or just a [\n            for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {\n                if (glob.startsWith(cls, i)) {\n                    // invalid, [a-[] is fine, but not [a-[:alpha]]\n                    if (rangeStart) {\n                        return ['$.', false, glob.length - pos, true];\n                    }\n                    i += cls.length;\n                    if (neg)\n                        negs.push(unip);\n                    else\n                        ranges.push(unip);\n                    uflag = uflag || u;\n                    continue WHILE;\n                }\n            }\n        }\n        // now it's just a normal character, effectively\n        escaping = false;\n        if (rangeStart) {\n            // throw this range away if it's not valid, but others\n            // can still match.\n            if (c > rangeStart) {\n                ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c));\n            }\n            else if (c === rangeStart) {\n                ranges.push(braceEscape(c));\n            }\n            rangeStart = '';\n            i++;\n            continue;\n        }\n        // now might be the start of a range.\n        // can be either c-d or c-] or c<more...>] or c] at this point\n        if (glob.startsWith('-]', i + 1)) {\n            ranges.push(braceEscape(c + '-'));\n            i += 2;\n            continue;\n        }\n        if (glob.startsWith('-', i + 1)) {\n            rangeStart = c;\n            i += 2;\n            continue;\n        }\n        // not the start of a range, just a single character\n        ranges.push(braceEscape(c));\n        i++;\n    }\n    if (endPos < i) {\n        // didn't see the end of the class, not a valid class,\n        // but might still be valid as a literal match.\n        return ['', false, 0, false];\n    }\n    // if we got no ranges and no negates, then we have a range that\n    // cannot possibly match anything, and that poisons the whole glob\n    if (!ranges.length && !negs.length) {\n        return ['$.', false, glob.length - pos, true];\n    }\n    // if we got one positive range, and it's a single character, then that's\n    // not actually a magic pattern, it's just that one literal character.\n    // we should not treat that as \"magic\", we should just return the literal\n    // character. [_] is a perfectly valid way to escape glob magic chars.\n    if (negs.length === 0 &&\n        ranges.length === 1 &&\n        /^\\\\?.$/.test(ranges[0]) &&\n        !negate) {\n        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];\n        return [regexpEscape(r), false, endPos - pos, false];\n    }\n    const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']';\n    const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']';\n    const comb = ranges.length && negs.length\n        ? '(' + sranges + '|' + snegs + ')'\n        : ranges.length\n            ? sranges\n            : snegs;\n    return [comb, uflag, endPos - pos, true];\n};\n//# sourceMappingURL=brace-expressions.js.map","/**\n * Un-escape a string that has been escaped with {@link escape}.\n *\n * If the {@link windowsPathsNoEscape} option is used, then square-brace\n * escapes are removed, but not backslash escapes.  For example, it will turn\n * the string `'[*]'` into `*`, but it will not turn `'\\\\*'` into `'*'`,\n * becuase `\\` is a path separator in `windowsPathsNoEscape` mode.\n *\n * When `windowsPathsNoEscape` is not set, then both brace escapes and\n * backslash escapes are removed.\n *\n * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped\n * or unescaped.\n */\nexport const unescape = (s, { windowsPathsNoEscape = false, } = {}) => {\n    return windowsPathsNoEscape\n        ? s.replace(/\\[([^\\/\\\\])\\]/g, '$1')\n        : s.replace(/((?!\\\\).|^)\\[([^\\/\\\\])\\]/g, '$1$2').replace(/\\\\([^\\/])/g, '$1');\n};\n//# sourceMappingURL=unescape.js.map","// parse a single path portion\nimport { parseClass } from './brace-expressions.js';\nimport { unescape } from './unescape.js';\nconst types = new Set(['!', '?', '+', '*', '@']);\nconst isExtglobType = (c) => types.has(c);\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = '(?!(?:^|/)\\\\.\\\\.?(?:$|/))';\nconst startNoDot = '(?!\\\\.)';\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set(['[', '.']);\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set(['..', '.']);\nconst reSpecials = new Set('().*{}+?[]^$\\\\!');\nconst regExpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// any single thing other than /\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + '+?';\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\nexport class AST {\n    type;\n    #root;\n    #hasMagic;\n    #uflag = false;\n    #parts = [];\n    #parent;\n    #parentIndex;\n    #negs;\n    #filledNegs = false;\n    #options;\n    #toString;\n    // set to true if it's an extglob with no children\n    // (which really means one child of '')\n    #emptyExt = false;\n    constructor(type, parent, options = {}) {\n        this.type = type;\n        // extglobs are inherently magical\n        if (type)\n            this.#hasMagic = true;\n        this.#parent = parent;\n        this.#root = this.#parent ? this.#parent.#root : this;\n        this.#options = this.#root === this ? options : this.#root.#options;\n        this.#negs = this.#root === this ? [] : this.#root.#negs;\n        if (type === '!' && !this.#root.#filledNegs)\n            this.#negs.push(this);\n        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;\n    }\n    get hasMagic() {\n        /* c8 ignore start */\n        if (this.#hasMagic !== undefined)\n            return this.#hasMagic;\n        /* c8 ignore stop */\n        for (const p of this.#parts) {\n            if (typeof p === 'string')\n                continue;\n            if (p.type || p.hasMagic)\n                return (this.#hasMagic = true);\n        }\n        // note: will be undefined until we generate the regexp src and find out\n        return this.#hasMagic;\n    }\n    // reconstructs the pattern\n    toString() {\n        if (this.#toString !== undefined)\n            return this.#toString;\n        if (!this.type) {\n            return (this.#toString = this.#parts.map(p => String(p)).join(''));\n        }\n        else {\n            return (this.#toString =\n                this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')');\n        }\n    }\n    #fillNegs() {\n        /* c8 ignore start */\n        if (this !== this.#root)\n            throw new Error('should only call on root');\n        if (this.#filledNegs)\n            return this;\n        /* c8 ignore stop */\n        // call toString() once to fill this out\n        this.toString();\n        this.#filledNegs = true;\n        let n;\n        while ((n = this.#negs.pop())) {\n            if (n.type !== '!')\n                continue;\n            // walk up the tree, appending everthing that comes AFTER parentIndex\n            let p = n;\n            let pp = p.#parent;\n            while (pp) {\n                for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {\n                    for (const part of n.#parts) {\n                        /* c8 ignore start */\n                        if (typeof part === 'string') {\n                            throw new Error('string part in extglob AST??');\n                        }\n                        /* c8 ignore stop */\n                        part.copyIn(pp.#parts[i]);\n                    }\n                }\n                p = pp;\n                pp = p.#parent;\n            }\n        }\n        return this;\n    }\n    push(...parts) {\n        for (const p of parts) {\n            if (p === '')\n                continue;\n            /* c8 ignore start */\n            if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {\n                throw new Error('invalid part: ' + p);\n            }\n            /* c8 ignore stop */\n            this.#parts.push(p);\n        }\n    }\n    toJSON() {\n        const ret = this.type === null\n            ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))\n            : [this.type, ...this.#parts.map(p => p.toJSON())];\n        if (this.isStart() && !this.type)\n            ret.unshift([]);\n        if (this.isEnd() &&\n            (this === this.#root ||\n                (this.#root.#filledNegs && this.#parent?.type === '!'))) {\n            ret.push({});\n        }\n        return ret;\n    }\n    isStart() {\n        if (this.#root === this)\n            return true;\n        // if (this.type) return !!this.#parent?.isStart()\n        if (!this.#parent?.isStart())\n            return false;\n        if (this.#parentIndex === 0)\n            return true;\n        // if everything AHEAD of this is a negation, then it's still the \"start\"\n        const p = this.#parent;\n        for (let i = 0; i < this.#parentIndex; i++) {\n            const pp = p.#parts[i];\n            if (!(pp instanceof AST && pp.type === '!')) {\n                return false;\n            }\n        }\n        return true;\n    }\n    isEnd() {\n        if (this.#root === this)\n            return true;\n        if (this.#parent?.type === '!')\n            return true;\n        if (!this.#parent?.isEnd())\n            return false;\n        if (!this.type)\n            return this.#parent?.isEnd();\n        // if not root, it'll always have a parent\n        /* c8 ignore start */\n        const pl = this.#parent ? this.#parent.#parts.length : 0;\n        /* c8 ignore stop */\n        return this.#parentIndex === pl - 1;\n    }\n    copyIn(part) {\n        if (typeof part === 'string')\n            this.push(part);\n        else\n            this.push(part.clone(this));\n    }\n    clone(parent) {\n        const c = new AST(this.type, parent);\n        for (const p of this.#parts) {\n            c.copyIn(p);\n        }\n        return c;\n    }\n    static #parseAST(str, ast, pos, opt) {\n        let escaping = false;\n        let inBrace = false;\n        let braceStart = -1;\n        let braceNeg = false;\n        if (ast.type === null) {\n            // outside of a extglob, append until we find a start\n            let i = pos;\n            let acc = '';\n            while (i < str.length) {\n                const c = str.charAt(i++);\n                // still accumulate escapes at this point, but we do ignore\n                // starts that are escaped\n                if (escaping || c === '\\\\') {\n                    escaping = !escaping;\n                    acc += c;\n                    continue;\n                }\n                if (inBrace) {\n                    if (i === braceStart + 1) {\n                        if (c === '^' || c === '!') {\n                            braceNeg = true;\n                        }\n                    }\n                    else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n                        inBrace = false;\n                    }\n                    acc += c;\n                    continue;\n                }\n                else if (c === '[') {\n                    inBrace = true;\n                    braceStart = i;\n                    braceNeg = false;\n                    acc += c;\n                    continue;\n                }\n                if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {\n                    ast.push(acc);\n                    acc = '';\n                    const ext = new AST(c, ast);\n                    i = AST.#parseAST(str, ext, i, opt);\n                    ast.push(ext);\n                    continue;\n                }\n                acc += c;\n            }\n            ast.push(acc);\n            return i;\n        }\n        // some kind of extglob, pos is at the (\n        // find the next | or )\n        let i = pos + 1;\n        let part = new AST(null, ast);\n        const parts = [];\n        let acc = '';\n        while (i < str.length) {\n            const c = str.charAt(i++);\n            // still accumulate escapes at this point, but we do ignore\n            // starts that are escaped\n            if (escaping || c === '\\\\') {\n                escaping = !escaping;\n                acc += c;\n                continue;\n            }\n            if (inBrace) {\n                if (i === braceStart + 1) {\n                    if (c === '^' || c === '!') {\n                        braceNeg = true;\n                    }\n                }\n                else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n                    inBrace = false;\n                }\n                acc += c;\n                continue;\n            }\n            else if (c === '[') {\n                inBrace = true;\n                braceStart = i;\n                braceNeg = false;\n                acc += c;\n                continue;\n            }\n            if (isExtglobType(c) && str.charAt(i) === '(') {\n                part.push(acc);\n                acc = '';\n                const ext = new AST(c, part);\n                part.push(ext);\n                i = AST.#parseAST(str, ext, i, opt);\n                continue;\n            }\n            if (c === '|') {\n                part.push(acc);\n                acc = '';\n                parts.push(part);\n                part = new AST(null, ast);\n                continue;\n            }\n            if (c === ')') {\n                if (acc === '' && ast.#parts.length === 0) {\n                    ast.#emptyExt = true;\n                }\n                part.push(acc);\n                acc = '';\n                ast.push(...parts, part);\n                return i;\n            }\n            acc += c;\n        }\n        // unfinished extglob\n        // if we got here, it was a malformed extglob! not an extglob, but\n        // maybe something else in there.\n        ast.type = null;\n        ast.#hasMagic = undefined;\n        ast.#parts = [str.substring(pos - 1)];\n        return i;\n    }\n    static fromGlob(pattern, options = {}) {\n        const ast = new AST(null, undefined, options);\n        AST.#parseAST(pattern, ast, 0, options);\n        return ast;\n    }\n    // returns the regular expression if there's magic, or the unescaped\n    // string if not.\n    toMMPattern() {\n        // should only be called on root\n        /* c8 ignore start */\n        if (this !== this.#root)\n            return this.#root.toMMPattern();\n        /* c8 ignore stop */\n        const glob = this.toString();\n        const [re, body, hasMagic, uflag] = this.toRegExpSource();\n        // if we're in nocase mode, and not nocaseMagicOnly, then we do\n        // still need a regular expression if we have to case-insensitively\n        // match capital/lowercase characters.\n        const anyMagic = hasMagic ||\n            this.#hasMagic ||\n            (this.#options.nocase &&\n                !this.#options.nocaseMagicOnly &&\n                glob.toUpperCase() !== glob.toLowerCase());\n        if (!anyMagic) {\n            return body;\n        }\n        const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '');\n        return Object.assign(new RegExp(`^${re}$`, flags), {\n            _src: re,\n            _glob: glob,\n        });\n    }\n    get options() {\n        return this.#options;\n    }\n    // returns the string match, the regexp source, whether there's magic\n    // in the regexp (so a regular expression is required) and whether or\n    // not the uflag is needed for the regular expression (for posix classes)\n    // TODO: instead of injecting the start/end at this point, just return\n    // the BODY of the regexp, along with the start/end portions suitable\n    // for binding the start/end in either a joined full-path makeRe context\n    // (where we bind to (^|/), or a standalone matchPart context (where\n    // we bind to ^, and not /).  Otherwise slashes get duped!\n    //\n    // In part-matching mode, the start is:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n    // - if dots allowed or not possible: ^\n    // - if dots possible and not allowed: ^(?!\\.)\n    // end is:\n    // - if not isEnd(): nothing\n    // - else: $\n    //\n    // In full-path matching mode, we put the slash at the START of the\n    // pattern, so start is:\n    // - if first pattern: same as part-matching mode\n    // - if not isStart(): nothing\n    // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n    // - if dots allowed or not possible: /\n    // - if dots possible and not allowed: /(?!\\.)\n    // end is:\n    // - if last pattern, same as part-matching mode\n    // - else nothing\n    //\n    // Always put the (?:$|/) on negated tails, though, because that has to be\n    // there to bind the end of the negated pattern portion, and it's easier to\n    // just stick it in now rather than try to inject it later in the middle of\n    // the pattern.\n    //\n    // We can just always return the same end, and leave it up to the caller\n    // to know whether it's going to be used joined or in parts.\n    // And, if the start is adjusted slightly, can do the same there:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n    // - if dots allowed or not possible: (?:/|^)\n    // - if dots possible and not allowed: (?:/|^)(?!\\.)\n    //\n    // But it's better to have a simpler binding without a conditional, for\n    // performance, so probably better to return both start options.\n    //\n    // Then the caller just ignores the end if it's not the first pattern,\n    // and the start always gets applied.\n    //\n    // But that's always going to be $ if it's the ending pattern, or nothing,\n    // so the caller can just attach $ at the end of the pattern when building.\n    //\n    // So the todo is:\n    // - better detect what kind of start is needed\n    // - return both flavors of starting pattern\n    // - attach $ at the end of the pattern when creating the actual RegExp\n    //\n    // Ah, but wait, no, that all only applies to the root when the first pattern\n    // is not an extglob. If the first pattern IS an extglob, then we need all\n    // that dot prevention biz to live in the extglob portions, because eg\n    // +(*|.x*) can match .xy but not .yx.\n    //\n    // So, return the two flavors if it's #root and the first child is not an\n    // AST, otherwise leave it to the child AST to handle it, and there,\n    // use the (?:^|/) style of start binding.\n    //\n    // Even simplified further:\n    // - Since the start for a join is eg /(?!\\.) and the start for a part\n    // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n    // or start or whatever) and prepend ^ or / at the Regexp construction.\n    toRegExpSource(allowDot) {\n        const dot = allowDot ?? !!this.#options.dot;\n        if (this.#root === this)\n            this.#fillNegs();\n        if (!this.type) {\n            const noEmpty = this.isStart() && this.isEnd();\n            const src = this.#parts\n                .map(p => {\n                const [re, _, hasMagic, uflag] = typeof p === 'string'\n                    ? AST.#parseGlob(p, this.#hasMagic, noEmpty)\n                    : p.toRegExpSource(allowDot);\n                this.#hasMagic = this.#hasMagic || hasMagic;\n                this.#uflag = this.#uflag || uflag;\n                return re;\n            })\n                .join('');\n            let start = '';\n            if (this.isStart()) {\n                if (typeof this.#parts[0] === 'string') {\n                    // this is the string that will match the start of the pattern,\n                    // so we need to protect against dots and such.\n                    // '.' and '..' cannot match unless the pattern is that exactly,\n                    // even if it starts with . or dot:true is set.\n                    const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);\n                    if (!dotTravAllowed) {\n                        const aps = addPatternStart;\n                        // check if we have a possibility of matching . or ..,\n                        // and prevent that.\n                        const needNoTrav = \n                        // dots are allowed, and the pattern starts with [ or .\n                        (dot && aps.has(src.charAt(0))) ||\n                            // the pattern starts with \\., and then [ or .\n                            (src.startsWith('\\\\.') && aps.has(src.charAt(2))) ||\n                            // the pattern starts with \\.\\., and then [ or .\n                            (src.startsWith('\\\\.\\\\.') && aps.has(src.charAt(4)));\n                        // no need to prevent dots if it can't match a dot, or if a\n                        // sub-pattern will be preventing it anyway.\n                        const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));\n                        start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : '';\n                    }\n                }\n            }\n            // append the \"end of path portion\" pattern to negation tails\n            let end = '';\n            if (this.isEnd() &&\n                this.#root.#filledNegs &&\n                this.#parent?.type === '!') {\n                end = '(?:$|\\\\/)';\n            }\n            const final = start + src + end;\n            return [\n                final,\n                unescape(src),\n                (this.#hasMagic = !!this.#hasMagic),\n                this.#uflag,\n            ];\n        }\n        // We need to calculate the body *twice* if it's a repeat pattern\n        // at the start, once in nodot mode, then again in dot mode, so a\n        // pattern like *(?) can match 'x.y'\n        const repeated = this.type === '*' || this.type === '+';\n        // some kind of extglob\n        const start = this.type === '!' ? '(?:(?!(?:' : '(?:';\n        let body = this.#partsToRegExp(dot);\n        if (this.isStart() && this.isEnd() && !body && this.type !== '!') {\n            // invalid extglob, has to at least be *something* present, if it's\n            // the entire path portion.\n            const s = this.toString();\n            this.#parts = [s];\n            this.type = null;\n            this.#hasMagic = undefined;\n            return [s, unescape(this.toString()), false, false];\n        }\n        // XXX abstract out this map method\n        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot\n            ? ''\n            : this.#partsToRegExp(true);\n        if (bodyDotAllowed === body) {\n            bodyDotAllowed = '';\n        }\n        if (bodyDotAllowed) {\n            body = `(?:${body})(?:${bodyDotAllowed})*?`;\n        }\n        // an empty !() is exactly equivalent to a starNoEmpty\n        let final = '';\n        if (this.type === '!' && this.#emptyExt) {\n            final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty;\n        }\n        else {\n            const close = this.type === '!'\n                ? // !() must match something,but !(x) can match ''\n                    '))' +\n                        (this.isStart() && !dot && !allowDot ? startNoDot : '') +\n                        star +\n                        ')'\n                : this.type === '@'\n                    ? ')'\n                    : this.type === '?'\n                        ? ')?'\n                        : this.type === '+' && bodyDotAllowed\n                            ? ')'\n                            : this.type === '*' && bodyDotAllowed\n                                ? `)?`\n                                : `)${this.type}`;\n            final = start + body + close;\n        }\n        return [\n            final,\n            unescape(body),\n            (this.#hasMagic = !!this.#hasMagic),\n            this.#uflag,\n        ];\n    }\n    #partsToRegExp(dot) {\n        return this.#parts\n            .map(p => {\n            // extglob ASTs should only contain parent ASTs\n            /* c8 ignore start */\n            if (typeof p === 'string') {\n                throw new Error('string type in extglob ast??');\n            }\n            /* c8 ignore stop */\n            // can ignore hasMagic, because extglobs are already always magic\n            const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);\n            this.#uflag = this.#uflag || uflag;\n            return re;\n        })\n            .filter(p => !(this.isStart() && this.isEnd()) || !!p)\n            .join('|');\n    }\n    static #parseGlob(glob, hasMagic, noEmpty = false) {\n        let escaping = false;\n        let re = '';\n        let uflag = false;\n        for (let i = 0; i < glob.length; i++) {\n            const c = glob.charAt(i);\n            if (escaping) {\n                escaping = false;\n                re += (reSpecials.has(c) ? '\\\\' : '') + c;\n                continue;\n            }\n            if (c === '\\\\') {\n                if (i === glob.length - 1) {\n                    re += '\\\\\\\\';\n                }\n                else {\n                    escaping = true;\n                }\n                continue;\n            }\n            if (c === '[') {\n                const [src, needUflag, consumed, magic] = parseClass(glob, i);\n                if (consumed) {\n                    re += src;\n                    uflag = uflag || needUflag;\n                    i += consumed - 1;\n                    hasMagic = hasMagic || magic;\n                    continue;\n                }\n            }\n            if (c === '*') {\n                if (noEmpty && glob === '*')\n                    re += starNoEmpty;\n                else\n                    re += star;\n                hasMagic = true;\n                continue;\n            }\n            if (c === '?') {\n                re += qmark;\n                hasMagic = true;\n                continue;\n            }\n            re += regExpEscape(c);\n        }\n        return [re, unescape(glob), !!hasMagic, uflag];\n    }\n}\n//# sourceMappingURL=ast.js.map","/**\n * Escape all magic characters in a glob pattern.\n *\n * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}\n * option is used, then characters are escaped by wrapping in `[]`, because\n * a magic character wrapped in a character class can only be satisfied by\n * that exact character.  In this mode, `\\` is _not_ escaped, because it is\n * not interpreted as a magic character, but instead as a path separator.\n */\nexport const escape = (s, { windowsPathsNoEscape = false, } = {}) => {\n    // don't need to escape +@! because we escape the parens\n    // that make those magic, and escaping ! as [!] isn't valid,\n    // because [!]] is a valid glob class meaning not ']'.\n    return windowsPathsNoEscape\n        ? s.replace(/[?*()[\\]]/g, '[$&]')\n        : s.replace(/[?*()[\\]\\\\]/g, '\\\\$&');\n};\n//# sourceMappingURL=escape.js.map","import { expand } from '@isaacs/brace-expansion';\nimport { assertValidPattern } from './assert-valid-pattern.js';\nimport { AST } from './ast.js';\nimport { escape } from './escape.js';\nimport { unescape } from './unescape.js';\nexport const minimatch = (p, pattern, options = {}) => {\n    assertValidPattern(pattern);\n    // shortcut: comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n        return false;\n    }\n    return new Minimatch(pattern, options).match(p);\n};\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/;\nconst starDotExtTest = (ext) => (f) => !f.startsWith('.') && f.endsWith(ext);\nconst starDotExtTestDot = (ext) => (f) => f.endsWith(ext);\nconst starDotExtTestNocase = (ext) => {\n    ext = ext.toLowerCase();\n    return (f) => !f.startsWith('.') && f.toLowerCase().endsWith(ext);\n};\nconst starDotExtTestNocaseDot = (ext) => {\n    ext = ext.toLowerCase();\n    return (f) => f.toLowerCase().endsWith(ext);\n};\nconst starDotStarRE = /^\\*+\\.\\*+$/;\nconst starDotStarTest = (f) => !f.startsWith('.') && f.includes('.');\nconst starDotStarTestDot = (f) => f !== '.' && f !== '..' && f.includes('.');\nconst dotStarRE = /^\\.\\*+$/;\nconst dotStarTest = (f) => f !== '.' && f !== '..' && f.startsWith('.');\nconst starRE = /^\\*+$/;\nconst starTest = (f) => f.length !== 0 && !f.startsWith('.');\nconst starTestDot = (f) => f.length !== 0 && f !== '.' && f !== '..';\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/;\nconst qmarksTestNocase = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExt([$0]);\n    if (!ext)\n        return noext;\n    ext = ext.toLowerCase();\n    return (f) => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestNocaseDot = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExtDot([$0]);\n    if (!ext)\n        return noext;\n    ext = ext.toLowerCase();\n    return (f) => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestDot = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExtDot([$0]);\n    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);\n};\nconst qmarksTest = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExt([$0]);\n    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);\n};\nconst qmarksTestNoExt = ([$0]) => {\n    const len = $0.length;\n    return (f) => f.length === len && !f.startsWith('.');\n};\nconst qmarksTestNoExtDot = ([$0]) => {\n    const len = $0.length;\n    return (f) => f.length === len && f !== '.' && f !== '..';\n};\n/* c8 ignore start */\nconst defaultPlatform = (typeof process === 'object' && process\n    ? (typeof process.env === 'object' &&\n        process.env &&\n        process.env.__MINIMATCH_TESTING_PLATFORM__) ||\n        process.platform\n    : 'posix');\nconst path = {\n    win32: { sep: '\\\\' },\n    posix: { sep: '/' },\n};\n/* c8 ignore stop */\nexport const sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep;\nminimatch.sep = sep;\nexport const GLOBSTAR = Symbol('globstar **');\nminimatch.GLOBSTAR = GLOBSTAR;\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?';\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\/|^)\\\\.).)*?';\nexport const filter = (pattern, options = {}) => (p) => minimatch(p, pattern, options);\nminimatch.filter = filter;\nconst ext = (a, b = {}) => Object.assign({}, a, b);\nexport const defaults = (def) => {\n    if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n        return minimatch;\n    }\n    const orig = minimatch;\n    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));\n    return Object.assign(m, {\n        Minimatch: class Minimatch extends orig.Minimatch {\n            constructor(pattern, options = {}) {\n                super(pattern, ext(def, options));\n            }\n            static defaults(options) {\n                return orig.defaults(ext(def, options)).Minimatch;\n            }\n        },\n        AST: class AST extends orig.AST {\n            /* c8 ignore start */\n            constructor(type, parent, options = {}) {\n                super(type, parent, ext(def, options));\n            }\n            /* c8 ignore stop */\n            static fromGlob(pattern, options = {}) {\n                return orig.AST.fromGlob(pattern, ext(def, options));\n            }\n        },\n        unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),\n        escape: (s, options = {}) => orig.escape(s, ext(def, options)),\n        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),\n        defaults: (options) => orig.defaults(ext(def, options)),\n        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),\n        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),\n        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),\n        sep: orig.sep,\n        GLOBSTAR: GLOBSTAR,\n    });\n};\nminimatch.defaults = defaults;\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nexport const braceExpand = (pattern, options = {}) => {\n    assertValidPattern(pattern);\n    // Thanks to Yeting Li <https://github.com/yetingli> for\n    // improving this regexp to avoid a ReDOS vulnerability.\n    if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n        // shortcut. no need to expand.\n        return [pattern];\n    }\n    return expand(pattern);\n};\nminimatch.braceExpand = braceExpand;\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nexport const makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();\nminimatch.makeRe = makeRe;\nexport const match = (list, pattern, options = {}) => {\n    const mm = new Minimatch(pattern, options);\n    list = list.filter(f => mm.match(f));\n    if (mm.options.nonull && !list.length) {\n        list.push(pattern);\n    }\n    return list;\n};\nminimatch.match = match;\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/;\nconst regExpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\nexport class Minimatch {\n    options;\n    set;\n    pattern;\n    windowsPathsNoEscape;\n    nonegate;\n    negate;\n    comment;\n    empty;\n    preserveMultipleSlashes;\n    partial;\n    globSet;\n    globParts;\n    nocase;\n    isWindows;\n    platform;\n    windowsNoMagicRoot;\n    regexp;\n    constructor(pattern, options = {}) {\n        assertValidPattern(pattern);\n        options = options || {};\n        this.options = options;\n        this.pattern = pattern;\n        this.platform = options.platform || defaultPlatform;\n        this.isWindows = this.platform === 'win32';\n        this.windowsPathsNoEscape =\n            !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;\n        if (this.windowsPathsNoEscape) {\n            this.pattern = this.pattern.replace(/\\\\/g, '/');\n        }\n        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;\n        this.regexp = null;\n        this.negate = false;\n        this.nonegate = !!options.nonegate;\n        this.comment = false;\n        this.empty = false;\n        this.partial = !!options.partial;\n        this.nocase = !!this.options.nocase;\n        this.windowsNoMagicRoot =\n            options.windowsNoMagicRoot !== undefined\n                ? options.windowsNoMagicRoot\n                : !!(this.isWindows && this.nocase);\n        this.globSet = [];\n        this.globParts = [];\n        this.set = [];\n        // make the set of regexps etc.\n        this.make();\n    }\n    hasMagic() {\n        if (this.options.magicalBraces && this.set.length > 1) {\n            return true;\n        }\n        for (const pattern of this.set) {\n            for (const part of pattern) {\n                if (typeof part !== 'string')\n                    return true;\n            }\n        }\n        return false;\n    }\n    debug(..._) { }\n    make() {\n        const pattern = this.pattern;\n        const options = this.options;\n        // empty patterns and comments match nothing.\n        if (!options.nocomment && pattern.charAt(0) === '#') {\n            this.comment = true;\n            return;\n        }\n        if (!pattern) {\n            this.empty = true;\n            return;\n        }\n        // step 1: figure out negation, etc.\n        this.parseNegate();\n        // step 2: expand braces\n        this.globSet = [...new Set(this.braceExpand())];\n        if (options.debug) {\n            this.debug = (...args) => console.error(...args);\n        }\n        this.debug(this.pattern, this.globSet);\n        // step 3: now we have a set, so turn each one into a series of\n        // path-portion matching patterns.\n        // These will be regexps, except in the case of \"**\", which is\n        // set to the GLOBSTAR object for globstar behavior,\n        // and will not contain any / characters\n        //\n        // First, we preprocess to make the glob pattern sets a bit simpler\n        // and deduped.  There are some perf-killing patterns that can cause\n        // problems with a glob walk, but we can simplify them down a bit.\n        const rawGlobParts = this.globSet.map(s => this.slashSplit(s));\n        this.globParts = this.preprocess(rawGlobParts);\n        this.debug(this.pattern, this.globParts);\n        // glob --> regexps\n        let set = this.globParts.map((s, _, __) => {\n            if (this.isWindows && this.windowsNoMagicRoot) {\n                // check if it's a drive or unc path.\n                const isUNC = s[0] === '' &&\n                    s[1] === '' &&\n                    (s[2] === '?' || !globMagic.test(s[2])) &&\n                    !globMagic.test(s[3]);\n                const isDrive = /^[a-z]:/i.test(s[0]);\n                if (isUNC) {\n                    return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];\n                }\n                else if (isDrive) {\n                    return [s[0], ...s.slice(1).map(ss => this.parse(ss))];\n                }\n            }\n            return s.map(ss => this.parse(ss));\n        });\n        this.debug(this.pattern, set);\n        // filter out everything that didn't compile properly.\n        this.set = set.filter(s => s.indexOf(false) === -1);\n        // do not treat the ? in UNC paths as magic\n        if (this.isWindows) {\n            for (let i = 0; i < this.set.length; i++) {\n                const p = this.set[i];\n                if (p[0] === '' &&\n                    p[1] === '' &&\n                    this.globParts[i][2] === '?' &&\n                    typeof p[3] === 'string' &&\n                    /^[a-z]:$/i.test(p[3])) {\n                    p[2] = '?';\n                }\n            }\n        }\n        this.debug(this.pattern, this.set);\n    }\n    // various transforms to equivalent pattern sets that are\n    // faster to process in a filesystem walk.  The goal is to\n    // eliminate what we can, and push all ** patterns as far\n    // to the right as possible, even if it increases the number\n    // of patterns that we have to process.\n    preprocess(globParts) {\n        // if we're not in globstar mode, then turn all ** into *\n        if (this.options.noglobstar) {\n            for (let i = 0; i < globParts.length; i++) {\n                for (let j = 0; j < globParts[i].length; j++) {\n                    if (globParts[i][j] === '**') {\n                        globParts[i][j] = '*';\n                    }\n                }\n            }\n        }\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            // aggressive optimization for the purpose of fs walking\n            globParts = this.firstPhasePreProcess(globParts);\n            globParts = this.secondPhasePreProcess(globParts);\n        }\n        else if (optimizationLevel >= 1) {\n            // just basic optimizations to remove some .. parts\n            globParts = this.levelOneOptimize(globParts);\n        }\n        else {\n            // just collapse multiple ** portions into one\n            globParts = this.adjascentGlobstarOptimize(globParts);\n        }\n        return globParts;\n    }\n    // just get rid of adjascent ** portions\n    adjascentGlobstarOptimize(globParts) {\n        return globParts.map(parts => {\n            let gs = -1;\n            while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n                let i = gs;\n                while (parts[i + 1] === '**') {\n                    i++;\n                }\n                if (i !== gs) {\n                    parts.splice(gs, i - gs);\n                }\n            }\n            return parts;\n        });\n    }\n    // get rid of adjascent ** and resolve .. portions\n    levelOneOptimize(globParts) {\n        return globParts.map(parts => {\n            parts = parts.reduce((set, part) => {\n                const prev = set[set.length - 1];\n                if (part === '**' && prev === '**') {\n                    return set;\n                }\n                if (part === '..') {\n                    if (prev && prev !== '..' && prev !== '.' && prev !== '**') {\n                        set.pop();\n                        return set;\n                    }\n                }\n                set.push(part);\n                return set;\n            }, []);\n            return parts.length === 0 ? [''] : parts;\n        });\n    }\n    levelTwoFileOptimize(parts) {\n        if (!Array.isArray(parts)) {\n            parts = this.slashSplit(parts);\n        }\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/<e>/<rest> -> <pre>/<rest>\n            if (!this.preserveMultipleSlashes) {\n                for (let i = 1; i < parts.length - 1; i++) {\n                    const p = parts[i];\n                    // don't squeeze out UNC patterns\n                    if (i === 1 && p === '' && parts[0] === '')\n                        continue;\n                    if (p === '.' || p === '') {\n                        didSomething = true;\n                        parts.splice(i, 1);\n                        i--;\n                    }\n                }\n                if (parts[0] === '.' &&\n                    parts.length === 2 &&\n                    (parts[1] === '.' || parts[1] === '')) {\n                    didSomething = true;\n                    parts.pop();\n                }\n            }\n            // <pre>/<p>/../<rest> -> <pre>/<rest>\n            let dd = 0;\n            while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n                const p = parts[dd - 1];\n                if (p && p !== '.' && p !== '..' && p !== '**') {\n                    didSomething = true;\n                    parts.splice(dd - 1, 2);\n                    dd -= 2;\n                }\n            }\n        } while (didSomething);\n        return parts.length === 0 ? [''] : parts;\n    }\n    // First phase: single-pattern processing\n    // <pre> is 1 or more portions\n    // <rest> is 1 or more portions\n    // <p> is any portion other than ., .., '', or **\n    // <e> is . or ''\n    //\n    // **/.. is *brutal* for filesystem walking performance, because\n    // it effectively resets the recursive walk each time it occurs,\n    // and ** cannot be reduced out by a .. pattern part like a regexp\n    // or most strings (other than .., ., and '') can be.\n    //\n    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n    // <pre>/<e>/<rest> -> <pre>/<rest>\n    // <pre>/<p>/../<rest> -> <pre>/<rest>\n    // **/**/<rest> -> **/<rest>\n    //\n    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n    // this WOULD be allowed if ** did follow symlinks, or * didn't\n    firstPhasePreProcess(globParts) {\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n            for (let parts of globParts) {\n                let gs = -1;\n                while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n                    let gss = gs;\n                    while (parts[gss + 1] === '**') {\n                        // <pre>/**/**/<rest> -> <pre>/**/<rest>\n                        gss++;\n                    }\n                    // eg, if gs is 2 and gss is 4, that means we have 3 **\n                    // parts, and can remove 2 of them.\n                    if (gss > gs) {\n                        parts.splice(gs + 1, gss - gs);\n                    }\n                    let next = parts[gs + 1];\n                    const p = parts[gs + 2];\n                    const p2 = parts[gs + 3];\n                    if (next !== '..')\n                        continue;\n                    if (!p ||\n                        p === '.' ||\n                        p === '..' ||\n                        !p2 ||\n                        p2 === '.' ||\n                        p2 === '..') {\n                        continue;\n                    }\n                    didSomething = true;\n                    // edit parts in place, and push the new one\n                    parts.splice(gs, 1);\n                    const other = parts.slice(0);\n                    other[gs] = '**';\n                    globParts.push(other);\n                    gs--;\n                }\n                // <pre>/<e>/<rest> -> <pre>/<rest>\n                if (!this.preserveMultipleSlashes) {\n                    for (let i = 1; i < parts.length - 1; i++) {\n                        const p = parts[i];\n                        // don't squeeze out UNC patterns\n                        if (i === 1 && p === '' && parts[0] === '')\n                            continue;\n                        if (p === '.' || p === '') {\n                            didSomething = true;\n                            parts.splice(i, 1);\n                            i--;\n                        }\n                    }\n                    if (parts[0] === '.' &&\n                        parts.length === 2 &&\n                        (parts[1] === '.' || parts[1] === '')) {\n                        didSomething = true;\n                        parts.pop();\n                    }\n                }\n                // <pre>/<p>/../<rest> -> <pre>/<rest>\n                let dd = 0;\n                while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n                    const p = parts[dd - 1];\n                    if (p && p !== '.' && p !== '..' && p !== '**') {\n                        didSomething = true;\n                        const needDot = dd === 1 && parts[dd + 1] === '**';\n                        const splin = needDot ? ['.'] : [];\n                        parts.splice(dd - 1, 2, ...splin);\n                        if (parts.length === 0)\n                            parts.push('');\n                        dd -= 2;\n                    }\n                }\n            }\n        } while (didSomething);\n        return globParts;\n    }\n    // second phase: multi-pattern dedupes\n    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n    //\n    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n    // ^-- not valid because ** doens't follow symlinks\n    secondPhasePreProcess(globParts) {\n        for (let i = 0; i < globParts.length - 1; i++) {\n            for (let j = i + 1; j < globParts.length; j++) {\n                const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);\n                if (matched) {\n                    globParts[i] = [];\n                    globParts[j] = matched;\n                    break;\n                }\n            }\n        }\n        return globParts.filter(gs => gs.length);\n    }\n    partsMatch(a, b, emptyGSMatch = false) {\n        let ai = 0;\n        let bi = 0;\n        let result = [];\n        let which = '';\n        while (ai < a.length && bi < b.length) {\n            if (a[ai] === b[bi]) {\n                result.push(which === 'b' ? b[bi] : a[ai]);\n                ai++;\n                bi++;\n            }\n            else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {\n                result.push(a[ai]);\n                ai++;\n            }\n            else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {\n                result.push(b[bi]);\n                bi++;\n            }\n            else if (a[ai] === '*' &&\n                b[bi] &&\n                (this.options.dot || !b[bi].startsWith('.')) &&\n                b[bi] !== '**') {\n                if (which === 'b')\n                    return false;\n                which = 'a';\n                result.push(a[ai]);\n                ai++;\n                bi++;\n            }\n            else if (b[bi] === '*' &&\n                a[ai] &&\n                (this.options.dot || !a[ai].startsWith('.')) &&\n                a[ai] !== '**') {\n                if (which === 'a')\n                    return false;\n                which = 'b';\n                result.push(b[bi]);\n                ai++;\n                bi++;\n            }\n            else {\n                return false;\n            }\n        }\n        // if we fall out of the loop, it means they two are identical\n        // as long as their lengths match\n        return a.length === b.length && result;\n    }\n    parseNegate() {\n        if (this.nonegate)\n            return;\n        const pattern = this.pattern;\n        let negate = false;\n        let negateOffset = 0;\n        for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n            negate = !negate;\n            negateOffset++;\n        }\n        if (negateOffset)\n            this.pattern = pattern.slice(negateOffset);\n        this.negate = negate;\n    }\n    // set partial to true to test if, for example,\n    // \"/a/b\" matches the start of \"/*/b/*/d\"\n    // Partial means, if you run out of file before you run\n    // out of pattern, then that's fine, as long as all\n    // the parts match.\n    matchOne(file, pattern, partial = false) {\n        const options = this.options;\n        // UNC paths like //?/X:/... can match X:/... and vice versa\n        // Drive letters in absolute drive or unc paths are always compared\n        // case-insensitively.\n        if (this.isWindows) {\n            const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0]);\n            const fileUNC = !fileDrive &&\n                file[0] === '' &&\n                file[1] === '' &&\n                file[2] === '?' &&\n                /^[a-z]:$/i.test(file[3]);\n            const patternDrive = typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0]);\n            const patternUNC = !patternDrive &&\n                pattern[0] === '' &&\n                pattern[1] === '' &&\n                pattern[2] === '?' &&\n                typeof pattern[3] === 'string' &&\n                /^[a-z]:$/i.test(pattern[3]);\n            const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;\n            const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;\n            if (typeof fdi === 'number' && typeof pdi === 'number') {\n                const [fd, pd] = [file[fdi], pattern[pdi]];\n                if (fd.toLowerCase() === pd.toLowerCase()) {\n                    pattern[pdi] = fd;\n                    if (pdi > fdi) {\n                        pattern = pattern.slice(pdi);\n                    }\n                    else if (fdi > pdi) {\n                        file = file.slice(fdi);\n                    }\n                }\n            }\n        }\n        // resolve and reduce . and .. portions in the file as well.\n        // dont' need to do the second phase, because it's only one string[]\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            file = this.levelTwoFileOptimize(file);\n        }\n        this.debug('matchOne', this, { file, pattern });\n        this.debug('matchOne', file.length, pattern.length);\n        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {\n            this.debug('matchOne loop');\n            var p = pattern[pi];\n            var f = file[fi];\n            this.debug(pattern, p, f);\n            // should be impossible.\n            // some invalid regexp stuff in the set.\n            /* c8 ignore start */\n            if (p === false) {\n                return false;\n            }\n            /* c8 ignore stop */\n            if (p === GLOBSTAR) {\n                this.debug('GLOBSTAR', [pattern, p, f]);\n                // \"**\"\n                // a/**/b/**/c would match the following:\n                // a/b/x/y/z/c\n                // a/x/y/z/b/c\n                // a/b/x/b/x/c\n                // a/b/c\n                // To do this, take the rest of the pattern after\n                // the **, and see if it would match the file remainder.\n                // If so, return success.\n                // If not, the ** \"swallows\" a segment, and try again.\n                // This is recursively awful.\n                //\n                // a/**/b/**/c matching a/b/x/y/z/c\n                // - a matches a\n                // - doublestar\n                //   - matchOne(b/x/y/z/c, b/**/c)\n                //     - b matches b\n                //     - doublestar\n                //       - matchOne(x/y/z/c, c) -> no\n                //       - matchOne(y/z/c, c) -> no\n                //       - matchOne(z/c, c) -> no\n                //       - matchOne(c, c) yes, hit\n                var fr = fi;\n                var pr = pi + 1;\n                if (pr === pl) {\n                    this.debug('** at the end');\n                    // a ** at the end will just swallow the rest.\n                    // We have found a match.\n                    // however, it will not swallow /.x, unless\n                    // options.dot is set.\n                    // . and .. are *never* matched by **, for explosively\n                    // exponential reasons.\n                    for (; fi < fl; fi++) {\n                        if (file[fi] === '.' ||\n                            file[fi] === '..' ||\n                            (!options.dot && file[fi].charAt(0) === '.'))\n                            return false;\n                    }\n                    return true;\n                }\n                // ok, let's see if we can swallow whatever we can.\n                while (fr < fl) {\n                    var swallowee = file[fr];\n                    this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee);\n                    // XXX remove this slice.  Just pass the start index.\n                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n                        this.debug('globstar found match!', fr, fl, swallowee);\n                        // found a match.\n                        return true;\n                    }\n                    else {\n                        // can't swallow \".\" or \"..\" ever.\n                        // can only swallow \".foo\" when explicitly asked.\n                        if (swallowee === '.' ||\n                            swallowee === '..' ||\n                            (!options.dot && swallowee.charAt(0) === '.')) {\n                            this.debug('dot detected!', file, fr, pattern, pr);\n                            break;\n                        }\n                        // ** swallows a segment, and continue.\n                        this.debug('globstar swallow a segment, and continue');\n                        fr++;\n                    }\n                }\n                // no match was found.\n                // However, in partial mode, we can't say this is necessarily over.\n                /* c8 ignore start */\n                if (partial) {\n                    // ran out of file\n                    this.debug('\\n>>> no match, partial?', file, fr, pattern, pr);\n                    if (fr === fl) {\n                        return true;\n                    }\n                }\n                /* c8 ignore stop */\n                return false;\n            }\n            // something other than **\n            // non-magic patterns just have to match exactly\n            // patterns with magic have been turned into regexps.\n            let hit;\n            if (typeof p === 'string') {\n                hit = f === p;\n                this.debug('string match', p, f, hit);\n            }\n            else {\n                hit = p.test(f);\n                this.debug('pattern match', p, f, hit);\n            }\n            if (!hit)\n                return false;\n        }\n        // Note: ending in / means that we'll get a final \"\"\n        // at the end of the pattern.  This can only match a\n        // corresponding \"\" at the end of the file.\n        // If the file ends in /, then it can only match a\n        // a pattern that ends in /, unless the pattern just\n        // doesn't have any more for it. But, a/b/ should *not*\n        // match \"a/b/*\", even though \"\" matches against the\n        // [^/]*? pattern, except in partial mode, where it might\n        // simply not be reached yet.\n        // However, a/b/ should still satisfy a/*\n        // now either we fell off the end of the pattern, or we're done.\n        if (fi === fl && pi === pl) {\n            // ran out of pattern and filename at the same time.\n            // an exact hit!\n            return true;\n        }\n        else if (fi === fl) {\n            // ran out of file, but still had pattern left.\n            // this is ok if we're doing the match as part of\n            // a glob fs traversal.\n            return partial;\n        }\n        else if (pi === pl) {\n            // ran out of pattern, still have file left.\n            // this is only acceptable if we're on the very last\n            // empty segment of a file with a trailing slash.\n            // a/* should match a/b/\n            return fi === fl - 1 && file[fi] === '';\n            /* c8 ignore start */\n        }\n        else {\n            // should be unreachable.\n            throw new Error('wtf?');\n        }\n        /* c8 ignore stop */\n    }\n    braceExpand() {\n        return braceExpand(this.pattern, this.options);\n    }\n    parse(pattern) {\n        assertValidPattern(pattern);\n        const options = this.options;\n        // shortcuts\n        if (pattern === '**')\n            return GLOBSTAR;\n        if (pattern === '')\n            return '';\n        // far and away, the most common glob pattern parts are\n        // *, *.*, and *.<ext>  Add a fast check method for those.\n        let m;\n        let fastTest = null;\n        if ((m = pattern.match(starRE))) {\n            fastTest = options.dot ? starTestDot : starTest;\n        }\n        else if ((m = pattern.match(starDotExtRE))) {\n            fastTest = (options.nocase\n                ? options.dot\n                    ? starDotExtTestNocaseDot\n                    : starDotExtTestNocase\n                : options.dot\n                    ? starDotExtTestDot\n                    : starDotExtTest)(m[1]);\n        }\n        else if ((m = pattern.match(qmarksRE))) {\n            fastTest = (options.nocase\n                ? options.dot\n                    ? qmarksTestNocaseDot\n                    : qmarksTestNocase\n                : options.dot\n                    ? qmarksTestDot\n                    : qmarksTest)(m);\n        }\n        else if ((m = pattern.match(starDotStarRE))) {\n            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;\n        }\n        else if ((m = pattern.match(dotStarRE))) {\n            fastTest = dotStarTest;\n        }\n        const re = AST.fromGlob(pattern, this.options).toMMPattern();\n        if (fastTest && typeof re === 'object') {\n            // Avoids overriding in frozen environments\n            Reflect.defineProperty(re, 'test', { value: fastTest });\n        }\n        return re;\n    }\n    makeRe() {\n        if (this.regexp || this.regexp === false)\n            return this.regexp;\n        // at this point, this.set is a 2d array of partial\n        // pattern strings, or \"**\".\n        //\n        // It's better to use .match().  This function shouldn't\n        // be used, really, but it's pretty convenient sometimes,\n        // when you just want to work with a regex.\n        const set = this.set;\n        if (!set.length) {\n            this.regexp = false;\n            return this.regexp;\n        }\n        const options = this.options;\n        const twoStar = options.noglobstar\n            ? star\n            : options.dot\n                ? twoStarDot\n                : twoStarNoDot;\n        const flags = new Set(options.nocase ? ['i'] : []);\n        // regexpify non-globstar patterns\n        // if ** is only item, then we just do one twoStar\n        // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n        // if ** is last, append (\\/twoStar|) to previous\n        // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n        // then filter out GLOBSTAR symbols\n        let re = set\n            .map(pattern => {\n            const pp = pattern.map(p => {\n                if (p instanceof RegExp) {\n                    for (const f of p.flags.split(''))\n                        flags.add(f);\n                }\n                return typeof p === 'string'\n                    ? regExpEscape(p)\n                    : p === GLOBSTAR\n                        ? GLOBSTAR\n                        : p._src;\n            });\n            pp.forEach((p, i) => {\n                const next = pp[i + 1];\n                const prev = pp[i - 1];\n                if (p !== GLOBSTAR || prev === GLOBSTAR) {\n                    return;\n                }\n                if (prev === undefined) {\n                    if (next !== undefined && next !== GLOBSTAR) {\n                        pp[i + 1] = '(?:\\\\/|' + twoStar + '\\\\/)?' + next;\n                    }\n                    else {\n                        pp[i] = twoStar;\n                    }\n                }\n                else if (next === undefined) {\n                    pp[i - 1] = prev + '(?:\\\\/|' + twoStar + ')?';\n                }\n                else if (next !== GLOBSTAR) {\n                    pp[i - 1] = prev + '(?:\\\\/|\\\\/' + twoStar + '\\\\/)' + next;\n                    pp[i + 1] = GLOBSTAR;\n                }\n            });\n            return pp.filter(p => p !== GLOBSTAR).join('/');\n        })\n            .join('|');\n        // need to wrap in parens if we had more than one thing with |,\n        // otherwise only the first will be anchored to ^ and the last to $\n        const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', ''];\n        // must match entire pattern\n        // ending in a * or ** will make it less strict.\n        re = '^' + open + re + close + '$';\n        // can match anything, as long as it's not this.\n        if (this.negate)\n            re = '^(?!' + re + ').+$';\n        try {\n            this.regexp = new RegExp(re, [...flags].join(''));\n            /* c8 ignore start */\n        }\n        catch (ex) {\n            // should be impossible\n            this.regexp = false;\n        }\n        /* c8 ignore stop */\n        return this.regexp;\n    }\n    slashSplit(p) {\n        // if p starts with // on windows, we preserve that\n        // so that UNC paths aren't broken.  Otherwise, any number of\n        // / characters are coalesced into one, unless\n        // preserveMultipleSlashes is set to true.\n        if (this.preserveMultipleSlashes) {\n            return p.split('/');\n        }\n        else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n            // add an extra '' for the one we lose\n            return ['', ...p.split(/\\/+/)];\n        }\n        else {\n            return p.split(/\\/+/);\n        }\n    }\n    match(f, partial = this.partial) {\n        this.debug('match', f, this.pattern);\n        // short-circuit in the case of busted things.\n        // comments, etc.\n        if (this.comment) {\n            return false;\n        }\n        if (this.empty) {\n            return f === '';\n        }\n        if (f === '/' && partial) {\n            return true;\n        }\n        const options = this.options;\n        // windows: need to use /, not \\\n        if (this.isWindows) {\n            f = f.split('\\\\').join('/');\n        }\n        // treat the test path as a set of pathparts.\n        const ff = this.slashSplit(f);\n        this.debug(this.pattern, 'split', ff);\n        // just ONE of the pattern sets in this.set needs to match\n        // in order for it to be valid.  If negating, then just one\n        // match means that we have failed.\n        // Either way, return on the first hit.\n        const set = this.set;\n        this.debug(this.pattern, 'set', set);\n        // Find the basename of the path by looking for the last non-empty segment\n        let filename = ff[ff.length - 1];\n        if (!filename) {\n            for (let i = ff.length - 2; !filename && i >= 0; i--) {\n                filename = ff[i];\n            }\n        }\n        for (let i = 0; i < set.length; i++) {\n            const pattern = set[i];\n            let file = ff;\n            if (options.matchBase && pattern.length === 1) {\n                file = [filename];\n            }\n            const hit = this.matchOne(file, pattern, partial);\n            if (hit) {\n                if (options.flipNegate) {\n                    return true;\n                }\n                return !this.negate;\n            }\n        }\n        // didn't get any hits.  this is success if it's a negative\n        // pattern, failure otherwise.\n        if (options.flipNegate) {\n            return false;\n        }\n        return this.negate;\n    }\n    static defaults(def) {\n        return minimatch.defaults(def).Minimatch;\n    }\n}\n/* c8 ignore start */\nexport { AST } from './ast.js';\nexport { escape } from './escape.js';\nexport { unescape } from './unescape.js';\n/* c8 ignore stop */\nminimatch.AST = AST;\nminimatch.Minimatch = Minimatch;\nminimatch.escape = escape;\nminimatch.unescape = unescape;\n//# sourceMappingURL=index.js.map","import MagicString from 'magic-string';\nimport { minimatch } from 'minimatch';\nimport { mergeConfig, PluginOption } from 'vite';\nimport pkg from '../package.json' with { type: 'json' };\n\nexport interface VueComponentOverrideOptions {\n  extensions?: string[];\n  handleStaticImports?: boolean;\n  handleDynamicImports?: boolean;\n  alias?: Record<string, string> | AliasCallback;\n  excludes?: string[] | string | RegExp[] | RegExp | ExcludeCallback;\n}\n\nexport type AliasCallback = (id: string) => string | undefined | null;\nexport type ExcludeCallback = (code: string, id: string) => boolean | undefined | null;\n\nexport default function vueComponentOverride(options: VueComponentOverrideOptions = {}): PluginOption {\n  const extensions = options.extensions ?? ['js', 'ts', 'jsx', 'tsx', 'vue'];\n  const handleStaticImports = options.handleStaticImports ?? true;\n  const handleDynamicImports = options.handleDynamicImports ?? true;\n  const excludes = options.excludes;\n  const aliasOption = options.alias;\n  const uid = Math.random().toString(36).substring(2, 8);\n\n  return [\n    {\n      name: 'vue-component-override',\n      enforce: 'pre',\n      // config(config) {\n      //   if (typeof config.build?.rollupOptions?.external === 'function') {\n      //     const originalExternal = config.build.rollupOptions.external;\n      //     config.build.rollupOptions.external = (source, ...rest) => {\n      //       if (source === pkg.name) {\n      //         return true;\n      //       }\n      //       return originalExternal(source, ...rest);\n      //     };\n      //   } else {\n      //     config = mergeConfig(config, {\n      //       build: {\n      //         rollupOptions: {\n      //           external: [\n      //             pkg.name\n      //           ]\n      //         }\n      //       }\n      //     });\n      //   }\n      //\n      //   return config;\n      // },\n      transform(code, id) {\n        const fileUri = new URL(id, 'file://');\n\n        if (id.endsWith('.vue')) {\n          // if (id.includes('Additional')) {\n          //   console.log(id, code);\n          // }\n\n          if (fileUri.searchParams.get('setup') !== 'true') {\n            return null;\n          }\n        }\n\n        if (!new RegExp(`\\\\.(${extensions.join('|')})$`).test(id)) {\n          return null;\n        }\n\n        // Use the top-level helper to decide exclusion\n        if (isExcluded(excludes, code, id)) {\n          return null;\n        }\n\n        let safeCode = stripComments(code);\n\n        let shouldAddResolver = false;\n        let shouldAddAsyncResolver = false;\n        const resolveFuncName = `__VUE_COMPONENT_OVERRIDE_RESOLVE_${uid}__`;\n        const resolveAsyncFuncName = `__VUE_COMPONENT_OVERRIDE_ASYNC_RESOLVE_${uid}__`;\n\n        const s = new MagicString(code);\n\n        if (handleStaticImports) {\n          const regex = /import\\s+(.*?)\\s+from\\s+['\"]((.*?)\\.vue)['\"]\\s*(;?)/g;\n\n          let matches: RegExpExecArray | null;\n\n          while (matches = regex.exec(safeCode)) {\n            const [match, component, uri] = matches;\n\n            if (component.includes('__Tmp')) {\n              continue;\n            }\n\n            const start = matches.index;\n            const end = start + match.length;\n\n            const tmpName = component + '__Tmp' + Math.floor(Math.random() * 100000);\n            let replaced = `import ${tmpName} from '${uri}';\\n\nconst ${component} = ${resolveFuncName}('${component}', ${tmpName});`;\n\n            shouldAddResolver = true;\n\n            s.overwrite(start, end, replaced);\n          }\n        }\n\n        if (handleDynamicImports) {\n          const regex = /(const|let|var)\\s+(\\w+)\\s*=\\s*defineAsyncComponent\\(\\s*\\(\\s*=>\\s*import\\(\\s*['\"]([^'\"]+?\\.vue)['\"]\\s*\\)\\s*\\)\\s*\\)/g;\n\n          let matches: RegExpExecArray | null;\n          while (matches = regex.exec(safeCode)) {\n            const [match, sign, component, uri] = matches;\n\n            const start = matches.index;\n            const end = start + match.length;\n\n            const replaced = `${sign} ${component} = ${resolveFuncName}('${component}', defineAsyncComponent(() => import('${uri}')))`\n\n            shouldAddAsyncResolver = true;\n\n            s.overwrite(start, end, replaced);\n          }\n        }\n\n        if (shouldAddResolver) {\n          addResolverToFile('resolveVueComponent', resolveFuncName, s, safeCode, id);\n        }\n\n        if (shouldAddAsyncResolver) {\n          addResolverToFile('resolveVueAsyncComponent', resolveAsyncFuncName, s, safeCode, id);\n        }\n        // if (id.includes('Additional')) {\n        //   console.log(s.toString());\n        // }\n        return {\n          code: s.toString(),\n          map: s.generateMap({\n            source: id,\n            hires: true,\n            includeContent: true\n          }),\n        };\n      }\n    }\n  ];\n};\n\nfunction resolveAlias(alias: VueComponentOverrideOptions['alias'], id: string): string {\n  if (!alias) {\n    return id;\n  }\n\n  if (typeof alias === 'function') {\n    const result = alias(id);\n    if (result) {\n      return result;\n    }\n  } else {\n    for (const [key, value] of Object.entries(alias)) {\n      if (id.startsWith(key)) {\n        return id.replace(key, value);\n      }\n    }\n  }\n\n  return id;\n}\n\nfunction addResolverToFile(importName: string, funcName: string, s: MagicString, code: string, id: string) {\n  // Use RegExp object\n  if (!new RegExp(`{.*?${funcName}.*?}\\s+from`).test(code)) {\n    const importLine = `import { ${importName} as ${funcName} } from '${pkg.name}';\\n`\n\n    // Add import at file top but after vue <script*>\n    if (id.endsWith('.vue')) {\n      const vueScriptMatch = code.match(/<script(.*?)?>/);\n      if (vueScriptMatch) {\n        const insertPos = vueScriptMatch.index! + vueScriptMatch[0].length;\n        s.appendLeft(insertPos, `\\n${importLine}`);\n      } else {\n        s.prepend(importLine);\n      }\n    } else {\n      s.prepend(importLine);\n    }\n  }\n\n  return code;\n}\n\nfunction isExcluded(\n  excludes: VueComponentOverrideOptions['excludes'],\n  code: string,\n  id: string\n): boolean {\n  id = id.replace(/\\\\/g, '/'); // Normalize Windows paths\n\n  if (!excludes) {\n    return false;\n  }\n\n  if (typeof excludes === 'function') {\n    try {\n      return !!excludes(code, id);\n    } catch (e) {\n      // If the user-provided function throws, treat as not excluded\n      return false;\n    }\n  }\n\n  const excludeList = Array.isArray(excludes) ? excludes : [excludes as string | RegExp];\n\n  for (const exclude of excludeList) {\n    if (exclude instanceof RegExp) {\n      if (exclude.test(id)) {\n        return true;\n      }\n    } else {\n      if (minimatch(id, exclude)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\ntype CommentPlaceholder = { key: string; value: string; };\n\nfunction stripComments(code: string): string {\n  return code\n    .replace(/\\/\\*[\\s\\S]*?\\*\\//g, (m) => ' '.repeat(m.length))\n    .replace(/\\/\\/.*$/gm, (m) => ' '.repeat(m.length))\n}\n\nfunction restoreComments(code: string, comments: CommentPlaceholder[]): string {\n  for (const { key, value } of comments) {\n    const re = new RegExp(key, 'g');\n    code = code.replace(re, value);\n  }\n\n  return code;\n}\n"],"names":["n","segment","isExcluded","match","replacement","unescape","regExpEscape","qmark","star","i","acc","ext","start","final"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9]}